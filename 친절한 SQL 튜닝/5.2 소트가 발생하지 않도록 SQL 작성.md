# 5.2 소트가 발생하지 않도록 SQL 작성

발표자: No
범위: 5.2
생성일시: June 16, 2022 8:24 AM
작성자: 석현임
최종편집: June 17, 2022 1:43 PM

# 5.2.1 Union vs Union All

- Union을 사용하면 옵티마이저는 상단과 하둔 두 집합 간 중복을 저거하기 위해 소트 작업을 수행한다
- Union All은 중복을 확인하지 않고 두 집합을 단순히 결합하므로 소트 작업을 수행하지 않는다.
- 성능을 위해 Union All을 사용해야한다.
- 주의 할 점은 Union을 Union All로 변경하려다 자칫 결과 집합이 달라질 수 있으므로 주의해야한다.
- Union 대신 Union All을 사용해도 되는지 정확히 판단하려면 데이터 모델에 대한 이해와 집합적 사고가 필요하다. 판단을 하지 목한다면 데이터 중복, 혹시 모를 데이터 중복을 유ㅜ려해 중복 제거용 연산자를 불필요하게 자주 사용하게 된다.

```sql
SELECT 결제번호, 주문번호, 결제금액, 주문일자 …
  FROM 결제
 WHERE 결제수단코드 = 'M' AND 결제일자 = '20180316'
 UNION
SELECT 결제번호, 주문번호, 결제금액, 주문일자 …
  FROM 결제
 WHERE 결제수단코드 = 'C' AND 결제일자 = '20180316'
```

- 결제 수단 코드 조건절에 다른 값을 입력했기 떄문에 Union 상단과 하단 집합 사이에 인스턴즈 중복 가능성이 없다.
- 하지만 Union을 사용함으로 인해 소트 연산을 발생시키고 있다.
- 두 집합이 상호배타적이므로 Union 대신 Union All을 사용해도 된다.

```sql
SELECT 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 …
  FROM 결제
 WHERE **결제일자** = '20180316'
 UNION
SELECT 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 …
 FROM 결제
 WHERE **주문일자** = '20180316'
```

- 결제일자와 주문일자 조건은 상호배타적 조건이 아니기 떄문에 인스턴스 중복 가능성이 있다.
- 만약 Union을 Union All로 변경하면 졀제일자와 주문일자가 같은 결제 데이터가 중복해서 출력된다.

```sql
SELECT 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 …
  FROM 결제
 WHERE 결제일자 = '20180316'
 UNION ALL
SELECT 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 …
  FROM 결제
 WHERE 주문일자 = '20180316'
   AND 결제일자 <> '20180316'
-- 결제 일자가 Null 허용 컬럼이면 맨 아래 조건절을 아래와 같이 변경
(결제일자 <> '20180316' or 결제일자 is null)
-- LNNVL 함수를 이용해도 무관하다
NNVL(결제일자 = '20180316')
```

- Union All을 하면서도 데이터중복을 피하기 위한 SQL이다.

# 5.2.2 Exist 활용

Distict 연산자를 중복 레코드를 제거할 목적으로 종종 사용하지만 조건에 해당하는 데이터를 모두 읽어서 중복을 제거를 함으로 많은 I/O가 발생하여 성능을 저하시킨다.

```sql
SELECT DISTINCT p.상품번호, p.상품명, p.상품가격, ...
  FROM 상품 p, 계약 c
 WHERE p.상품유형코드 = :pclscd
   AND c.상품번호 = p.상품번호
   AND c.계약일자 BETWEEN :dt1 AND :dt2
   AND c.계약구분코드 = :ctpcd

-- 위 Distict 를 Exists를 활용하여 변경한 SQL
SELECT p.상품번호, p.상품명, p.상품가격, ...
  FROM 상품 p
 WHERE p.상품유형코드 = :pclscd
   AND EXISTS ( SELECT 'X' FROM 계약 c
                 WHERE c.상품번호 = p.상품번호
                   AND c.계약일자 BETWEEN :dt1 AND :dt2
								   AND c.계약구분코드 = :ctpcd
							)
```

- Exists 서브 쿼리는 데이터 존재 여부만 확인하면 되기 때문에 조건절을 만족하는 테이블 모두 읽지 않는다.
- Distict 연산자를 사용하지 않았으므로 상품 테이블에 대한 부분범위 처리도 가능하다.
- Distict, Minus 연산자를 사용한 쿼리는 대부분 Exists 서브쿼리로 변환 가능하다.

# 5.2.3 조인 방식 변경

- 인덱스에 따라 해시 조인일떄 Sort Order By를 한다.
- 힌트를 사용하여 NL 조인 방식을 사용하도록 변경하면 소트 연산을 생략할 수 있다.