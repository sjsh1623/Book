# 1.1 SQL 파싱과 최적화

# 1.1.1 구조적, 집합적, 선언적 질의 언어

SQL(Structured Query Language)이란 구조적 질의 언어다.

- SQL is designed for a specific purpose: to query data contained in a relational database.
- SQL is a **set-based**, **declarative** programming language, not an imperative programming language like C or BASIC.

SQl은 말 그대로 구조적, 집합적, 선언적인 질의 언어이다. 원하는 결과를 구조적, 집합적으로 선언하지만, 그 결과 집합을 생성하기 위해서는 프로시저 (절차적인 과정)이 필요하다. 그런 프로시저를 DBMS 내부 엔진인 SQL 옵티마이저가 만들어낸다. 즉, 옵티마이저가 프로그래밍을 대신해준다.

# 1.1.2 SQL 최적화

DBMS(Database Management Systems) 내부에서 프로시저를 작성하고 컴파일하여 실행 가능한 상태로 만드는 전 과정을 SQL 최적화라고 한다. 

SQL 실행 과정:

1. DBMS에 SQL 전달
2. SQL 파싱 
    1. 파싱 트리 생성
    2. Syntax (문법) 체크
    3. Semantic 체크 - 의미상 오류가 없는지 확인
3. SQL 최적화
4. SQL 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계 정보를 이용하여 다양한 실행경로를 생성하여 가장 효율적인 하나를 선택한다.
5. 로우 소스 생성기를 사용하여 선택한 실행경로를 실제 실행 가능한 코드 (로우 코드)로 포맷팅 한다.

# 1.1.3 SQL 옵티마이저

SQL 옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 엑세스 경로를 선택해 주는 DBMS의 핵심 엔진이다.

SQL 옵티마이저는 네비게이션의 추천 경로와 같다. 

1. 후보군이 될만한 실행계획들을 찾아내어 통계 정보를 이용하여 예상 비용 (경로) 을 산정한다. 
2. 그 중에서 가장 낮은 최저 비용 (가장 짧은 거리)을 선택한다.
3. 로우 소스 생성기에게 전달한다.

> SQL 옵티마이저는 별도의 프로세스가 아닌 서버 프로세스가 가진 하나의 Function이며 로우 소스 생성기도 마찬가지다.
> 

# 1.1.4 실행계획과 비용

실행계획 (Execution Plan)은 네비게이션의 경로 미리보기와 흡사하다. 
SQL 옵티마이저가 생성한 처리절차를 사용자가 확인 할 수 있게 트리 구조로 표현한것이 실행 계획이다. 
하지만 SQL 실행계획에 표시되는 **Cost도 어디까지나 예상치다**. 실행경로를 선택하기 위해 옵티마이저가 여러 통계정보를 활용하여 계산해 낸 값이므로 실제 수행할 때 발생하는 I/O 또는 시간과 많은 차이가 난다.

# 1.1.5 옵티마이저 힌트

1.1.4 에서 작성하였듯 실행계획에 표시되는 Cost도 언제까지나 예상치 이며 완벽하지는 않다. 개발자가 직접 더 효율적인 엑세스 경로를 찾아낼 수 있다. 이럴 떄 옵티마이저 힌트를 이용해 데이터 엑세스 경로를 변경할 수 있다. 

 

아래와 같이 주석 시호에 _를 붙혀 사용하면 된다.

```sql
추천 사용방법
SELECT /*+ INDEX(A_고객_PK) */
	고객명, 연락처, 주소, 가입일시
	FROM 고객 A
  Where 고객ID = '0000'

비추천 사용방법 
아래와 같이 사용할 경우 아래에 모든 SQL이 같이 주석처리 될 수 있기 떄문이다.
SELECT --+ INDEX(A_고객_PK)
	고객명, 연락처, 주소, 가입일시
	FROM 고객 A
  Where 고객ID = '0000'
```

주의 사항

- 힌트 안에 인자를 나열할 땐 , (콤마)를 사용할 수 있지만, 힌트와 힌트 사이에 사용하지 않는다
- 테이블을 지정할 때 스키마명까지 명시하지 않는다
- FROM 절 테이블명 옆에 ALIAS를 지정했다면, 힌트에서도 반드시 ALIAS를 사용한다.