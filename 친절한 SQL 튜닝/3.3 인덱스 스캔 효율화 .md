# 3.3 인덱스 스캔 효율화

# 3.3.1 인덱스 탐색

```sql
< 조건절 1 > 
where C1 = 'B'

< 조건절 2 > 
where C1 = 'B' 
and C2 = 3

< 조건절 3 > 
where C1 = 'B' 
and C2 >= 3

< 조건절 4 > 
where C1 = 'B' 
and C2 <= 3

< 조건절 5 > 
where C1 = 'B' 
and C2 between 2 and 3

< 조건절 6 > 
where C1 = between 'A' and 'C' 
and C2 between 2 and 3
```

# 3.3.2 인덱스 스캔 효율성

**질문 1**

‘성능검'으로 시작하는 용어를 검색하고자 할 떄 어디서 스캔을 시작하고 어디서 멈출까?

- 가나다 순으로 정렬돼 있으므로 바로 이 지점으로 찾아갈 수 있다.
- 용어가 ‘성능계수'인 지점에서 멈춘다. (’성능검'으로 시작하는 용어가 더 없음을 확인하기 위해 총 3건을 읽는다)

**질문 2**

‘성능'으로 시작하고 네 번째 문자가 ‘선’ 인용어를 검색해보자. 어디서 스캔을 시작하고 어디서 멈출까?

- ‘성능'으로 시작하는 용어를 모두 스캔한다.
- 결과는 똑같이 두 건 이지만 1번 보다 윌씬 더 많은 용어를 스캔했다.

**질문 3** 

‘성능검'으로 시작하는 레코드를 검색하려면, 아래와 같은 조건절을 사용한다. 아 조건절에 인덱스를 사용한다면, 어디서 스캔을 시작하고 어디서 멈출까?

```sql
where c1 = '성'
and c2 = '능'
and c3 = '검'
```

- 수직적 탐색을 통해 ‘성능검사' 레코드를 찾아간다. 거기서 스캔을 시작해 ‘성능계수'까지 총 세개 레코드를 스캔하고 멈춘다.

**질문 4**

‘성능'으로 시작하고 네 번째 컬럼이 ‘선'인 레코드를 검색하려면, 아래와 같은 조건절을 사용한다. 인덱스를 사용한다면, 어디서 스캔을 시작하고 어디서 멈출까?

- 성능으로 시작하는 레코드를 모드 스캔한다.
- 결과는 똑같이 2건이지만 3번보다 더 많은 인덱스 레코드를 스캔해야한다.

| C1 | C2 | C3 | C4 |
| --- | --- | --- | --- |
| 성 | 능 | 감 | 시 |
| 성 | 능 | 개 | 량 |
| 성 | 능 | 개 | 선 |
| 성 | 능 | 검 | 수 |
| 성 | 능 | 검 | 증 |
| 성 | 능 | 계 | 수 |
| 성 | 능 | 계 | 측 |
| 성 | 능 | 곡 | 선 |
| 성 | 능 | 관 | 리 |
| 성 | 능 | 시 | 험 |
| 성 | 능 | 이 | 론 |
| 성 | 능 | 지 | 수 |
| 성 | 능 | 측 | 정 |
| 성 | 능 | 튜 | 닝 |
| 성 | 능 | 평 | 가 |
| 성 | 능 | 호 | 환 |

인덱스 스캔을 통해 얻은 결과 건수는 똑같은데 왜 인덱스 리프 블록에서 스캔하는 레코드 개수에 차이가 생기는 걸까?

- 인덱스 선행 컬럼이 없기 때문이다. 위 인덱스로 말하면 C4보다 앞선 선행 컬럼 C3가 조건절에 없기 떄문이다.
- 인덱스 선행 컬림이 조건절에 없거나 ‘=’ 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.

# 3.3.3 엑세스 조건과 필터 조건

**엑세스 조건**

- 인덱스 스캔 범위를 결정하는 조건절이다.
- 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는데 영향을 미치는 조건절이다.

**필터 조건**

- 인덱스를 이용하든, 테이블을 Full Scan 하든, 테이블 엑세스 단계에서 처리되는 조건절이다.

> **옵티마이저 비용 계산**
> 
> 
> = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
> 
> = 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 +
> 
> 인덱스 리프 블록을 스캔하는 과정에서 읽는 블록 수 +
> 
> 테이블 액세스 과정에서 읽는 블록 수
> 

# 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

```sql
< 조건절 1 > 
where C1 = 1
and C2 = 'A'
and C3 = '나'
and C4 = 'a'
-- 인덱스 구성 컬럼 (C1, C2, C3, C4) 모두 '=' 조건으로 비료할 때는 조건을 만족하는 레코드들이 
-- 모두 연속해서 모여있다.

< 조건절 2 > 
where C1 = 1
and C2 = 'A'
and C3 = '나'
and C4 >= 'a'
-- 선행 컬림은 모두 '='이고 맨 마지막 컬럼만 범위검색 조건 
-- (Between, Like)일 떄도 조건을 만족하는 레코드가 서로 모여있다
-- 5 ~ 7번

< 조건절 3 > 
where C1 = 1
and C2 = 'A'
and C3 = between '가' and '다'
and C4 = 'a'
-- 준간 컬럼이 범위검색 조건일 떄는 C1 부터 C3까지 세 조건을 만족하는 인덱스 레코드는 
-- 서로 모여있지만 C4조건을 만족하는 레코드는 흩어지게 된다
-- 5 ~ 10번

< 조건절 4 > 
where C1 = 1
and C2 <= 'B'
and C3 = '나'
and C4 between 'a' and 'b'
-- C2가 범위검색 조건인 경우는 C1 부터 C2까지 두 조건을 만족하는 인덱스 레코드는 서로 모여있지만 (2 ~ 12번)
-- C3와 C4 조건까지 만족하는 레코드는 흩어지게 된다.
-- 2,3,5,6,7,11번

< 조건절 5 > 
where C1 between 1 and 3
and C2 = 'A'
and C3 = '나'
and C4 = 'a'
-- 선두 C1 컬럼이 범위검색 조건이면 C1 조건을 만족하는 레코드는 서로 모여있고, 
-- 나머지 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어지게 된다.
-- 5,6,7,8,9,14,15번
```

첫 번쨰 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.

# 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 떄 생기는 비효율

- 인덱 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다.

```sql
-- Index = 아파트 시세코드 + 평형 + 평형타입 + 인터넷 매물 
where 아파트 시세코드 = :a
where 아파트 시세코드 = :a and 평형 = :b
where 아파트 시세코드 = :a and 평형 = :b and 평형타입 = :c
where 아파트 시세코드 = :a and 평형 = :b and 평형타입 = :c between :c and :d
```

위 조건절은 모두 인덱스 엑세스 조건으로 사용된다.

```sql
-- Index = 아파트 시세코드 + 평형 + 평형타입 + 인터넷 매물 
select 해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
from 매물아파트매매
where 아파트시세코드='A01011359000056'
and 평형 = '59'
and 평형타입 = 'A'
and 인터넷 매물 between  '1' and '3'
order by 입력일 desc
```

인덱스 선행 컬림이 조건절에 없거나 부등호, Between, Like 같은 범위 검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생긴다.

- 인덱스 선행 컬림이 모두 ‘=’ 조건일 때 필요한 범위만 스캔하고 멈출 수 있는, 조건을 만족하는 레코드가 모두 한데 모여 있기 떄문이다.

# 3.3.6 BETWEEN을 IN_List로 전환

```sql
select 해당층, 평당가, 입력일, 해당동, 매물구분, 연사용일수, 중개업소코드
from 매물아파트매매
where 인터넷매물 in ('1', '2', '3')
and 아파트시세코드='A01011359000056'
and 평형 = '59'
and 평형타입 = 'A'
order by 입력일 desc
```

- 인덱스를 변경하기 어려울때는 Between 조건을 In-List로 바꿔주면 큰 효과를 얻는 경우가 있다.

**Between 조건을 In-List로 전활할 때 주의 사항**

- IN-List 개수가 많지 않아야 한다 IN-List 개수가 많으면 수직적 탐색이 많이 발생한다.
- 인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다.
- Between 조건 때문에 인덱스를 비효율적으로 스캔하더라도 블록 I/O 측면에서는 대개 소량에 그치는 경우가 많다.

# 3.3.7 Index Skip Scan 활용

- 선두 컬럼이 Between이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 떄 , Index Skip Scan의 위력이 나타난다.

# 3.3.8 IN 조건은 ‘=’인가

- IN 조건은 ‘=’이 아니다. IN 조건이 ‘=’이 되려면 IN-List Iterator 방식으로 풀려야만 한다. 그렇지 않으면 IN 조건은 필터 조건이다.
- 데이터가 적을시에는 필터 방식으로 처리되는게 오히려 낫다.

**NUM_INDEX_KEYS 힌트 활용**

- NUM_INDEX_KEY 힌트는 인덱스 엑세스 조건으로 사용한다.
- 세번째 파라미터 1은 인덱스 첫번째 컬럼까지만 엑세스 조건으로 사용하라는 의미이다.

```sql
select /* + num_index_keys(a 고객별 가입상품_x1 1 )*/
from 고객별가입 상품 a
where 고객번호 = :cust_no
and 상품ID in (...)
```

힌트를 사용하지 않고 인덱스 컬럼을 가공하여 IN-List Iterator 방식으로 풀리면서 인덱스 엑세스 조건으로 사용된다.

# 3.3.9 Between 과 Like 스캔 범위 비교

LIKE를 보통 편리하기 떄문에 사용을 많이 하지만 LIKE 보다 BETWEEN을 사용하는게 낫다.

```sql
<조건절 1>
where 판매월 BETWEEN '201901' and '201912'
and 판매구분 = 'B'

<조건절 2>
where 판매월 LIKE '2019%'
and 판매구분 = 'B'
```

- LIKE를 사용하여 검색했을때 ‘201900’이 혹시라도 저장되어 있다면 해당 값도 읽어야 하므로 판매 구분 =’B’인 지점으로 바로 내려갈 수 없다.

```sql
<조건절 3>
where 판매월 BETWEEN '201901' and '201912'
and 판매구분 = 'A'

<조건절 4>
where 판매월 LIKE '2019%'
and 판매구분 = 'A'
```

- 조건절 1, 2와 반대로 B의 데이터 양이 많다고 가정했을때의 LIKE절은 판매구분 = ‘A’에서 멈추지 않고 전체를 스켄하고 멈춘다.

# 3.3.10 범위검색 조건을 남용할 떄 생기는 비효율

```sql
-- IDX 회사, 지역, 상품명

<쿼리 1> 회사, 지역, 상품명 모두 입력
SELECT ....
FROM  가입상품
WHERE 회사 = :com
AND   지역 = :reg
AND   상품명 LIKE :prod || '%'
-- 세 컬럼 모두 엑세스 조건이므로 아주 적은 범위만 스캔하고 빠르게 결과를 출력할 수 있다

<쿼리 2> 회사, 상품명만 입력 
SELECT ....
FROM  가입상품
WHERE 회사 = :com
AND   상품명 LIKE :prod || '%'
-- 인덱스 중간 컬럼에 대한 조건이 없을 때는 어쩔 수 없이 넓은 범위를 스캔한다.
```

```sql
SELECT 고객ID, 상품명 ...
FROM  가입상품
WHERE 회사 = :com
AND   지역 LIKE :reg || '%'
AND   상품명 LIKE :prod || '%'
```

- 지역코드를 입력한 경우 인덱스 스캔 범위가 입력 안한 경우보다 스캔 범위가 늘어난다.
- 앞서 엑세스 조건이던 상품명이 필터 조건으로 바뀌면서 생긴 변화이다.

# 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

**OR 조건 활용**

```sql
select * from 거래
where (:cust_id is null or 고객ID  = :cust_id)
and 거래일자 between :dt1 and :dt2
```

- 옵티마이저에 의한 OR Expansion 퀴리 변환이 기본적으로 작동하지 않으므로, 인덱스 선두 컬ㄹㅁ에 대한 옵션 조건에 OR 조건을 사용해선 안된다.
- 인덱스에 포함되지 않은 컬럼에 대한 옵션 조건은 테이블에서 필터링 할 수 밖에 없으므로 OR 조건을 사용해도 무방하다.
- 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면 인덱스 필터 조건으로 사용가능하다.

**LIKE/BETWEEN 조건 활용**

- 변별력이 좋은 필수 조건이 있는 상황 (’=’)에서 LIKE/BETWEEN을 사용하는 것은 나쁘지 않다. 필수 조건 컬럼을 인덱스 선두에 두고 엑세스 조건으로 사용하면, LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다.
- LIKE/BETWEEN 패턴을 사용하고자 할 떄는 아래 네가지 경우에 속하는지 점검해야한다.
    - 인덱스 선두 컬럼 - LIKE/BETWEEN
    - NULL 허용 컬림 - LIKE/BETWEEN
    - 숫자형 컬림 - LIKE
    - 가변 길이 컬럼 -LIKE

**UNION ALL 활용**

```sql
select * from 거래
where :cust_id is null
and   거래일자 between :dt1 and :dt2
union all
select * from 거래
where :cust_id is not null
and   고객ID = :cust_id
and   거래일자 between :dt1 and :dt2
```

- or 조건을 사용하지 않고 UNION ALL을 사용하면 cust_id 변수에 값을 입력하든 안하든, 인덱스를 가장 최적으로 사용한다.

NVL/DECODE 함수 활용

```sql
select * from 거래
where 고객ID = nvl(:cust_id, 고객ID)
and   거래일자 between :dt1 and :dt2

또는

select * from 거래
where 고객ID = decode(:cust_id, null, 고객ID, :cust_id)
and   거래일자 between :dt1 and :dt2
```

- :cust_id 변수에 값을 입력하지 않으면 위쪽 브랜치에서 거래일자가 선두인 인덱스를 사용하고, 변수에 값을 입력하면 고객 ID + 거래일자 인덱스를 사용한다.
- NVL, DECODE 둘 중 어느 것을 사용하던, 실행계획은 같다.

# 3.3.12 함수호출부하 해소를 위한 인덱스 구성

**PL/SQL 함수의 성능적 특성**

- 개발자들이 일반적으로 생각하는 것보다 매우 느리다.
    - 가상머신(VM) 상에서 실행되는 인터프리터 언어
    - 호출 시마다 컨텍스트 스위칭 발생
    - 내장 SQL에 대한 Recursive Call 발생
- PL/SQL도 JAVA처럼 인터프리터 언어이기 떄문에 Native 코드로 완전 컴파일된 내장 함수에 비해 많이 느리다.

**효과적인 인덱스 구성을 통한 함수 호출 최소화**

```sql
-- 회원 테이블을 Full Scan 방식으로 읽으면 encryption 함수는 테이블 건수만큼 수행된다 --
select /*+ full(a) */ 회원번호, 회원명, 생년, 생월일, 등록일자
from   회원 a
where 암호화된_전화번호 = encryption(:phone_no)

-- encryption 함수는 그 조건절 (생년 = '1987")을 만족하는 건수만큼 수행된다.
select /*+ full(a) */ 회원번호, 회원명, 생년, 생월일, 등록일자
from   회원 a
where  생년 ='1987'
and    암호화된_전화번호 = encryption(:phone_no)

-- 암호화된_전화번호 조건절을 엑세스 단계에서 필터링 한다
-- encryption 함수는 테이블 엑세스 횟수 즉 생년 = '1987' 조건을 만족하는 건수만큼 수행된다
create index 회원_x01 on 회원(생년);

-- 암호화된_전화번호는 선행 컬림인 생년월일에 대한 '=' 조건이 없으므로 인덱스 필터 조건이다. 
-- encryption 함수는 테이블 엑세스 횟수 즉 생년 = '1987' 조건을 만족하는 건수만큼 수행된다
create index 회원_x02 on 회원(생년, 생월일, 암호화된_전화번호);

-- 암호화된_전화번호도 생년과 함께 인덱스 엑세스 조건으로 사용된다
-- encryption 함수는 한번만 수행된다
create index 회원_x03 on 회원(생년, 암호화된_전화번호);
```