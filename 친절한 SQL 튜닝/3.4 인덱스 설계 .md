# 3.4 인덱스 설계

# 3.4.1 인덱스 설계가 어려운 이유

인덱스가 많으면 아래와 같은 문제가 발생한다

- DML 성능 저하(→ TPS 저하)
- 데이터베이스 사이즈 증가(→디스크 공간 낭비)
- 데이터베이스 관리 및 운영 비용 상승

예를 들어 테이블에 인덱스 6개가 달려있다면, INSERT, DELETE시 레코드를 일일이 찾아 INSERT, DELETE해줘야한다.

# 3.4.2 가장 중요한 두 가지 선택 기준

- 인덱스 스캔방식중 가장 일반적인 방식은 Index Range Scan이다. 이를 위해서는 인덱스 선두 컬럼을 조건절에 반드시 사용해야한다.
- 결합 인덱스를 구성할 때 기준 두가지
    - 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다
    - ‘=’ 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.
    

# 3.4.3 스캔 효율성 이외의 판단 기준

- 공식대로 하려다 보면, 공식을 모르고 설계할 떄보다 오히려 인덱스 개수가 더 늘어나는 현상도 발생한다.
- 아래는 인덱스 스캔 효율성 판단 기준 (위 2개) 이 외 고려해야 할 판단 기준이다
    - 수행 빈도 (가장 중요)
    - 업무상 중요도
    - 클러스터링 팩터
    - 데이터량
    - DML 부하 (=기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등)
    - 저장 공간
    - 인덱스 관리 비용 등
- 수행 빈도가 높은 SQL이라면 테스트 과정에 당장 성능이 좋게 나오더라도 인덱스를 최종적으로 구성해줘야 한다.
- **NL 조인**(4장에서 설명. 다중 포문이라고 생각하면 된다.)은 Inner 쪽의 쿼리가 여러 번 수행되기 때문에 Inner은 '=' 조건 컬럼을 선두에 두어 인덱스를 최대한 타도록 해야 한다.
- 테이블량이 적다면 굳이 인덱스를 많이 만들 필요가 없다. FULL SCAN으로도 충분히 빠르기 때문이다.

# 3.4.4 공식을 초월한 전력적 설계

- 인덱스를 공식에 맞춰 만들면 좋지만 현실적으로 불가능하기 때문에 전략적으로 작성해야한다.
- 조건절 패턴이 열개 있을때, 패턴마다 인덱스를 하나씩 만들 수 없다.
- 조건 컬럼이 ’=’ 로 조회하는 것이 있고, BETWEEN으로 일자를 검색하는 쿼리가 있다고 가정하면 일자를 선두 컬럼으로 두고, 나머지 조건 컬럼을 뒤에 후행 컬럼으로 만드는게 좋다.
- 가장 많이 사용되는 '=' 조건 컬럼이 있다면 그 조건컬럼은 선두 컬럼으로 두고, 일자를 그 뒤로 두는 인덱스가 하나 정도 있는것도 좋다

# 3.4.5 소트 연상을 생략하기 위한 컬럼 추가

- 인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해준다.

```sql
SELECT 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
  FROM 계약
 WHERE 취급지점ID = :trt_brch_id
   AND 청약일자 BETWEEN :sbcp_dt1 AND :sbcp_dt2
   AND 입력일자 >= trunc(sysdate - 3)
   AND 계약상태코드 IN (:ctr_stat_cd1, :ctr_stat_cd2, :ctr_stat_cd3)
 ORDER BY 청약일자, 입력자ID
```

- ORDER BY 절 순서대로 idx: 청약일자 + 입력자 ID로 구성하면 소트연산이 생략된다.
- ‘=’이 아닌 조건절 컬럼들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 소트 연산을 생략할 수 있다.
(청약일자 + 입력자ID + 입력일자 + 계약상태코드)
- I/O를 최소화하면서 소트 연산을 생략하기 위한 인덱스 설계 공식
    1. '=' 연산자로 사용한 조건절 컬럼을 가장 앞에 선정
    2. ORDER BY 절에 기술한 컬럼 추가
    3. '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

**IN 조건은 ‘=’이 아니다**

- 소트 연산을 생략하려면 IN 조건절이 IN-List Iterator 방식으로 풀려선 안된다,. 즉 IN 조건절을 인덱스 엑세스 조건으로 사용되면 안된다. 필터 조건으로 사용해야 한다.

# 3.4.6 결합 인덱스 선택도

- 인덱 생성 여부를 결정할 떄는 선택도가 충분히 낮은지가 중요한 판단기준이다.
- ‘인덱스 선택도’는 인덱스 컬럼을 모두 ‘=’로 조회할 때 평균적으로 선택되는 비율을 의미한다

**컬럼 순서 결정 시, 선택도 이슈**

```sql
WHERE 성별 = :GENDER
AND 고객번호 = :CUST_NO
```

- 성별, 고객번호 둘다 인덱스 엑세스 조건이므로 어떤 컬럼이 앞에 오든 인덱스 스캔 범위는 동일하다. (인덱스 스캔 효율에 전혀 차이가 없다)
- 인덱스 생성 여부를 결정할 떄는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도 보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준이다.

# 3.4.7 중복 인덱스 제거

```sql
- X01 : 계약ID + 청약일자
- X02 : 계약ID + 청약일자 + 보험개시일자
- X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자
```

- 위 세 인덱스는 중복이다. X03 인덱스가 X01, X02 인덱스 전체를 완전히 포함하기 떄문이다.
- X03 인덱스를 남기고, X01, X02 인덱스는 삭제해도 된다.

```sql
- X01 : 계약ID + 청약일자
- X02 : 계약ID + 보험개시일자
- X03 : 계약ID + 보험종료일자
- X04 : 계약ID + 데이터생성일시
```

- 두 번쨰 컬림이 모두 다르기때문에 중복이 아니다
- 계약ID 평균 카디널리티가 5라고 가정하면 계약ID를  ‘=’조건으로 했을 경우 평균 다섯 건이 조회된다는 뜻이다.
- 위 4개의 인덱스를 ‘계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시’ 하나로 만들면 충분하다

**중복제거 실습 1**

> PK : 주소ID + 건물동번호 + 건물호번호 + 관리번호
N1 : 상태구분코드 + 관리번호
N2 : 관리번호
N3 : 주소ID + 관리번호
> 

| 컬럼명 | NDV |
| --- | --- |
| 주소ID | 736,000 |
| 건물동번호 | 175 |
| 건물호번호 | 3,052 |
| 관리번호 | 250,782 |
| 상태구분코드 | 3 |

- 상태구분코드는 NDV가 3이므로 선택도가 매우 높다
- N2 인덱스는 관리번호로 조회할 때만 사용되므로 아래와 같이 N2 인덱스를 제거하고 N1인덱스를 ‘관리번호 + 상태구분코드'순으로 변경한다.
- 관리번호로만 조회하든 상태구분코드까지 같이 조회하든 N1 인덱스를 사용하면 된다

# 3.4.8 인덱스 설계도 작성

- 249페이지 참조