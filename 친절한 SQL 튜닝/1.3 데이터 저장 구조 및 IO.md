# 1.3 데이터 저장 구조 및 I/O

# 1.3.1 SQL이 느린 이유

- SQL이 느린 이유는 디스크 I/O 때문이다.
- OS 또는 I/O 서브시스템이 I/O를 처리하는 동안 프로세스는 SLEEP하기 때문이다.
- 디스크에서 데이터를 읽어야 할 때는 CPU를 OS에 반환하고 잠시 수면 상태에서 I/O가 완료되기를 대기(wait)하기 떄문이다. (I/O call 하고 CPU 반환 → SLEEP)

> I/O (input/output), pronounced "eye-oh," describes any operation, program, or device that transfers data to or from a computer
컴퓨터와 데이터를 주고받는 모든 작업, 프로그램 또는 장치.
>

# 1.3.2 데이터베이스 저장 구조

데이터를 저장하려면 가장 먼저 **테이블 스페이스**가 필요하다.

- **테이블 스페이스**: 세그먼트를 담는 컨테이너 (여러개의 데이터 파일로 구성)
- **데이터 파일**: 디스크 상의 물리적인 OS 파일
- **세그먼트** : 데이터 저장공간이 필요한 오브젝트 (테이블, 인덱스, 파티션등 여러 익스텐트로 구성)
  - 테이블, 인덱스를 생성할 떄 데이터를 어떤 테이블 스페이스에 저장할지 지정한다
  - 파티션 구조가 아니라면, 테이블/인덱스는 각각 하나의 세그먼트이다.
  - 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다.
- **익스텐트**: 공간을 확장하는 단위, 연속된 블록의 집합
  - 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로 부터 익스텐그를 추가로 할당 받는다
- **블록** : 데이터를 읽고 쓰는 단위
  - 사용자가 입력한 레코드를 실제로 저장하는 공간
  - 페이지 라고도 불림 ( DB2, SQL Server )
  - 한 블록은 한 테이블이 독점한다 → 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다.

# 1.3.3 블록 단위 I/O

- DBMS가 데이터를 읽고 쓰는 단위를 블록이라고 한다.
- 테이블, 인덱스에서 특정 레코드 하나만 읽고 싶어도 해당 블록을 전체를 읽는다
  - 오라클은 기본적으로 8KB 크기의 블록을 사용하지만 1Byte를 읽기 위해 8KB 전체를 읽게된다.

# 1.3.4 시퀀셜 엑세스 vs. 랜던 엑세스

**시퀀셜(Sequential) 엑세스**

- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
- 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 연결되어있으며 이 주소 값에 따라 앞, 뒤를 순차적으로 스캔하는 방식이 시퀀셜 엑세스다.
- 테이블 블록 간에는 서로 논리적인 연결고리를 가지고 있지 않지만 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더 Map으로 관리한다. 익스텐트의 맵은 각 익스텐트의 첫 번째 블록 주소 값을 가지고 있기 때문에, 익스텐트 첫번째 블록부터 하나하나 읽으면 Full Table Scan이 된다.

**랜덤 엑세스**

- 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근(touch)하는 방식

# 1.3.5 논리적 I/O vs. 물리적 I/O

**DB 버퍼 캐시**

- 디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적은 I/O Call을 줄여 효율성을 높힌다.
- 데이터 블록을 읽을땐 항상 버퍼 캐시부터 탐색한다.
- 버퍼캐시는 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다

**논리적 I/O vs. 물리적 I/O**

- 논리적 I/O
  - SQL문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O를 말한다.
- 물리적 I/O
  - SQL 처리 도중 읽어야할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 엑세스하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O 한다.

디스크 I/O가 메모리 I/O 보다, 10000배쯤 느리다.

**버퍼캐시 히트율 (BCHR)**

> 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾는 비율
>

BCHR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) x 100

= ( (논리적I/O - 물리적I/O) / 논리적I/O ) x 100

= ( 1 - (물리적I/O) / (논리적 I/O) ) x 100

물리적 I/O = 논리적 I/O x ( 100 - BCHR )

- SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다
- 논리적 I/O를 줄이기는 방법중 하나는 SQL을 튜닝하여 읽는 총 블록 갯수를 줄이면된다.
- BCHR이 높다고 해서 무조건 효율적인 SQL을 의미하지 않는다
  - 같은 블록을 비효율적으로 반복해서 읽는 경우


# 1.3.6 Single Block I/O vs. Mutiblock I/O

Single Block I/O

- 한번에 한 블록씩 요청하여 메모리에 적재한다
- 인덱스를 이용할때는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다.
- 인덱스는 소량 데이터를 읽을 때 주로 사용함으로 Single Block I/O 방식이 효율적이다.

Multi Block I/O

- 한번에 여러 블록을 요청하여 메모리에 적재한다.
- 인덱스를 이용하지 않고 (소량 데이터) 테이블 전체 스캔할 때 사용한다.
- 테이블이 클수록 Multiblock I/O 단위도 크면 좋다. (프로세스가 잠자는 횟수를 줄여준다)
- 버퍼캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 I/O Call을 할 떄 디스크 상에 블록과 인접한 블록들을 한번에 읽어 버퍼캐시에 미리 적재하여 성늘을 높힌다.

# 1.3.7 Table Full Scan vs. Index Range Scan

Table Full Scan

- 테이블에 속한 블록 ‘전체'를 읽어서 사용자가 원하는 데이터를 찾는 방식이다.
- Mutiblock I/O

Index Range Scan

- 인덱스에서 ‘일정량'을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식이다.
- Single Block I/O

Table Full Scan이 항상 성능 저하를 일으키지는 않는다. 대량 데이터 검색에는 더 유리하다 상황에 따라 Table Full Scan이 성능 향상에 도움이 된다. 단, 소량에 데이터를 검색시 반드시 인덱스를 이용해야한다.

# 1.3.8 캐시 탐색 메커니즘

Direct Path I/O를 제외한 모든 블록 I/O메모리 버퍼캐시를 경유한다

버퍼캐시 탐색 과정 거치는 오퍼레이션

- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 이프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 테이블 블록을 Full Scan 할 때

같은 입력 값은 항상 동일한 해시 체인(버킷)에 연결된다.

다른 입력 값 (ex: 4,9)이 동일한 해시 체인에 연결될 수있지만 해시 체인 내에서는 정력이 보장되지 않는다.

> Example
버퍼캐시에서 20번 블록을 찾고자 한다. 블록 번호를 5로 나누면 나머지가 0이다.
이 블록이 캐싱돼 있다면, 버퍼 헤더가 첫 번째 해시 체인(해시 값 = 0)에 연결돼 있을 것이므로
찾을 때 항상 첫 번째 해시 체인만 탐색하면 된다.
출처: [https://www.notion.so/4f468fab737946368c0f435c2a367d7b](https://www.notion.so/4f468fab737946368c0f435c2a367d7b)
>

**메모리 공유자원에 대한 엑세스 직렬화**

- 버퍼캐시는 SGA 구성요소이므로 버퍼캐싱에 캐싱된 버퍼블록은 모두 공유자원이다.
- 하나의 버퍼블록을 두 개 이상의 프로세스가 동시에 접근하려고 할 때 블록의 정합성에 문제가 발생할 수 있다. 따라서 자원을 공유하는 것처럼 보여도 내부에서는 한 프로세스씩 순차적으로 접근 할 수 있도록 직렬화 (serialization) 메커니즘이 필요하다.
- 직렬화 가 가능하도록 지원하는 메커니즘이 래치(Latch)다.
- SGA를 구성하는 서브 캐시마다 별도의 래치가 존재하며, 버퍼캐시에는 캐시버퍼, 체인 레치, 캐시버퍼 LRU 페인 래치 등이 작동한다.
- 빠른 데이터베이스를 구현하려면 버커캐시 히트율을 높혀야하지만 래치에 의한 경합이 생길 수 있기 떄문에 I/O가 생각만큼 빠르지 않을 수 있다.

**버퍼 Lock**

- 읽고자 하는 블록을 찾았으면 캐시버퍼 체인 래치를 곧바로 해제해야한다.
- 같은 블록에 접근하여 데이터를 읽고 쓴다면 데이터 정합성에 문제가 발생 할 수 있으므로 이를 방지하기 위해 버퍼 Lock을 사용한다.
