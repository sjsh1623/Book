# 1.3 데이터 저장 구조 및 I/O

# 1.3.1 SQL이 느린 이유

- SQL이 느린 이유는 디스크 I/O 때문이다.
- OS 또는 I/O 서브시스템이 I/O를 처리하는 동안 프로세스는 SLEEP하기 때문이다.
- 디스크에서 데이터를 읽어야 할 때는 CPU를 OS에 반환하고 잠시 수면 상태에서 I/O가 완료되기를 대기(wait)하기 떄문이다. (I/O call 하고 CPU 반환 → SLEEP)

> I/O (input/output), pronounced "eye-oh," describes any operation, program, or device that transfers data to or from a computer
컴퓨터와 데이터를 주고받는 모든 작업, 프로그램 또는 장치.
> 

# 1.3.2 데이터베이스 저장 구조

데이터를 저장하려면 가장 먼저 **테이블 스페이스**가 필요하다.

- **테이블 스페이스**: 세그먼트를 담는 컨테이너 (여러개의 데이터 파일로 구성)
- **데이터 파일**: 디스크 상의 물리적인 OS 파일
- **세그먼트** : 데이터 저장공간이 필요한 오브젝트 (테이블, 인덱스, 파티션등 여러 익스텐트로 구성)
    - 테이블, 인덱스를 생성할 떄 데이터를 어떤 테이블 스페이스에 저장할지 지정한다
    - 파티션 구조가 아니라면, 테이블/인덱스는 각각 하나의 세그먼트이다.
    - 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다.
- **익스텐트**: 공간을 확장하는 단위, 연속된 블록의 집합
    - 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로 부터 익스텐그를 추가로 할당 받는다
- **블록** : 데이터를 읽고 쓰는 단위
    - 사용자가 입력한 레코드를 실제로 저장하는 공간
    - 페이지 라고도 불림 ( DB2, SQL Server )
    - 한 블록은 한 테이블이 독점한다 → 한 블록에 저장된 레코드는 모두 같은 테이블 레코드다.

# 1.3.3 블록 단위 I/O

- DBMS가 데이터를 읽고 쓰는 단위를 블록이라고 한다.
- 테이블, 인덱스에서 특정 레코드 하나만 읽고 싶어도 해당 블록을 전체를 읽는다
    - 오라클은 기본적으로 8KB 크기의 블록을 사용하지만 1Byte를 읽기 위해 8KB 전체를 읽게된다.

# 1.3.4 시퀀셜 엑세스 vs. 랜던 엑세스

**시퀀셜(Sequential) 엑세스**

- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
- 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 연결되어있으며 이 주소 값에 따라 앞, 뒤를 순차적으로 스캔하는 방식이 시퀀셜 엑세스다.
- 테이블 블록 간에는 서로 논리적인 연결고리를 가지고 있지 않지만 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더 Map으로 관리한다. 익스텐트의 맵은 각 익스텐트의 첫 번째 블록 주소 값을 가지고 있기 때문에, 익스텐트 첫번째 블록부터 하나하나 읽으면 Full Table Scan이 된다.

**랜덤 엑세스**

- 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근(touch)하는 방식

# 1.3.5 논리적 I/O vs. 물리적 I/O

**DB 버퍼 캐시**

- 디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적은 I/O Call을 줄여 효율성을 높힌다.
- 데이터 블록을 읽을땐 항상 버퍼 캐시부터 탐색한다.
- 버퍼캐시는 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다

**논리적 I/O vs. 물리적 I/O**

- 논리적 I/O
    - SQL문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O를 말한다.
- 물리적 I/O
    - SQL 처리 도중 읽어야할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 엑세스하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O 한다.

디스크 I/O가 메모리 I/O 보다, 10000배쯤 느리다.

**버퍼캐시 히트율 (BCHR)**

> 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾는 비율
> 

BCHR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) x 100

= ( (논리적I/O - 물리적I/O) / 논리적I/O ) x 100

= ( 1 - (물리적I/O) / (논리적 I/O) ) x 100

물리적 I/O = 논리적 I/O x ( 100 - BCHR )

- SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다
- 논리적 I/O를 줄이기는 방법중 하나는 SQL을 튜닝하여 읽는 총 블록 갯수를 줄이면된다.
- BCHR이 높다고 해서 무조건 효율적인 SQL을 의미하지 않는다
    - 같은 블록을 비효율적으로 반복해서 읽는 경우
    

# 1.3.6 Single Block I/O vs. Mutiblock I/O