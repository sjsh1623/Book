# 4.4 서브쿼리 조인

발표자: No
범위: 4.4
생성일시: June 9, 2022 8:15 AM
작성자: 석현임
최종편집: June 13, 2022 1:39 PM

# 4.4.1 서브쿼리 변환이 필요한 이유

- 쿼리 변환(Query Transformation)은 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다
- 서브쿼리는 하나의 SQL문 안에 괄호로 묶은 별도의 쿼리 블록을 말한다.
- 옵티마이저는 쿼리 블록 단위로 최적화를 수행한다.

서브쿼리를 DBMS마다 조금씩 다르게 분류하지만 오라클은 세가지로 분류한다.

1. 인라인 뷰 (Inline View) : From 절에 사용한 서브쿼리를 말한다.
2. 중첩된 서브쿼리(Nested Subquery) : 결과집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리를 말한다. 특히, 서브쿼리가 메인쿼리 컬럼을 참조하는 형태를 ‘상관관계 있는 서브쿼리'라고 부른다.
3. 스칼라 서브쿼리(Scalar Subquery) : 한 레코드당 정확히 하나의 값을 반환하는 서브쿼리다. 주로 SELECT-LIST에서 사용하지만 몇 가지 예외사항을 제외하면 컬럼이 올 수 있는 대부분 위치에 사용할 수 있다.

**<원본쿼리>**

```sql
select c.고객번호, c.고객명
  from 고객 c
 where c.가입일시 >= trunc(add_month(sysdate, -1), 'mm')
   and exists (
        	select 'x'
        	from 거래
        	where 고객번호 =c.고객번호
        	and 거래일시 >= trunc(sysdate, 'mm'))
```

**<쿼리 블록1>**

```sql
select c.고객번호, c.고객명
  from 고객 c
 where c.가입일시 >= trunc(add_month(sysdate, -1), 'mm')
```

**<쿼리 블록2>**

```sql
select 'x'
  from 거래
 where 고객번호 = :cust_no
   and 거래일시 >= trunc(sysdate, 'mm')
```

# 4.4.2 서브쿼리와 조인

- 서브쿼리는 메인 쿼리에 종속되므로 단독으로 실행할 수 없다. 메인쿼리 건수만큼 값을 받아 반복적으로 필터링 하는 방식으로 실행해야 한다.

**필터 오퍼레이션**

```sql
-- 서브쿼리를 필터 방식으로 처리하려고 의도적으로 no_unset 힌트를 사용
-- 서브쿼리를 풀어내지 말고 그래도 수행하라고 옵티마이저에게 지시하는 힌트
SELECT c.고객번호, c.고객명
  FROM 고객 c
 WHERE c.가입일시 >= TRUNC(add_months(sysdate, -1), ‘mm’)
   AND EXISTS (SELECT /*+ no_unnest */
                 FROM 거래
                WHERE 고객번호 = c.고객번호
                  AND 거래일시 >= TRUNC(SYSDATE, ‘mm’))
```

```sql
-- 서브쿼리를 필터 방식으로 처리하려고 의도적으로 no_unset 힌트를 사용
-- 서브쿼리를 풀어내지 말고 그래도 수행하라고 옵티마이저에게 지시하는 힌트
SELECT c.고객번호, c.고객명
  FROM 고객 c
 WHERE c.가입일시 >= TRUNC(add_months(sysdate, -1), ‘mm’)
   AND EXISTS (SELECT /*+ no_unnest */
                 FROM 거래
                WHERE 고객번호 = c.고객번호
                  AND 거래일시 >= TRUNC(SYSDATE, ‘mm’))
```

- 기본적으로 NL 조인과 처리 루틴이 같다.
- 두개의 쿼리를 각각 최적화하지 않고, NL 조인처럼 하나의 쿼리로 판단하여 최적화 한다.

**NL 조인과 필터 오퍼레이션의 차이점**

- 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고, 메인쿼리의 다음 로우를 계속 처리한다.
- 필터는 캐싱기능을 갖는다. 즉, 서브쿼리 입력 값에 따른 반환 값(boolean)을 캐싱하는 기능이다.
- 조인 순서는 항상 고정된다 메인 쿼리가 Outer, 서브쿼리가 Inner

**서브쿼리 Unnestring**

```sql
SELECT c.고객번호, c.고객명
  FROM 고객 c
 WHERE c.가입일시 >= TRUNC(add_months(sysdate, -1), ‘mm’)
   AND EXISTS (SELECT /*+ unnset nl_sj */
                 FROM 거래
                WHERE 고객번호 = c.고객번호
                  AND 거래일시 >= TRUNC(SYSDATE, ‘mm’))
```

- 메인 쿼리와 서브 쿼리간의 계층 구조를 없애고, 서로 같은 레벨로 쿼리를 처리하는 방식

|  | Filter 방식 | Unnesting 방식 |
| --- | --- | --- |
|  | no_unnest | unnest |
| Outer와 Inner 쿼리 | 항상 서브 쿼리가 Inner | 힌트를 이용해 선택 가능 |
| 조인 방식 | NL 조인 방식 | NL조인, 해시 조인 등 다양하게  |
- 위 테이블의 설명과 같이 NL 세미 조인은 기본적으로 NL 조인과 같은 프로세스이다.
- 조인에 성공하는 순간 진행을 멈추고 메인 쿼리의 다음 로우를 계속 처리한다는 점만 다르다.
- 서브 쿼리가 메인 쿼리 보다 먼저 처리 될 수도 있다.
- 서브 쿼리에 ROWNUM을 사용하면 unnest 힌트를 사용한다고 하여도 서브 쿼리를 최적하하지 않으니 ROWNUM을 서브 쿼리에 쓸 떄 유의해야한다.

**서브쿼리 Pushing**

- Unnestting 되지 않은 서브 쿼리는 항상 필터 방식으로 처리된다.
- 이 기능은 Unnesting 되지 않은 서브쿼리에만 작동한다.
- 조건절에 존재하는 서브 쿼리에 해당하는 데이터가 적다면 서브 쿼리가 먼저 수행되는 것이 좋다. 하지만 필터 방식의 서브 쿼리는 대게 맨 마지막에 처리되므로, 이를 가장 먼저 처리되도록 강제하는 기능이다.
- 필터 방식에서만 사용 가능하기 때문에 no_unnest 힌트와 같이 힌트를 사용한다.
- 가장 나중에 처리하게 하려면 no_push_subq를 사용하면 된다.

# 4.4.3 뷰(View)와 조인

- 최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰(View) 쿼리를 반환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화한다.

```sql
SELECT 
	...
FROM 고객 C
	,(SELECT ... FROM 거래 
WHERE 거래일시 >= trunc(sysdate, 'mm') -- 당월 발생환 거래
GROUP BY 고객번호) T
WHERE C.가입일시 >= trunc(add_months(sysdate, -1), 'mm') -- 전월 이후 가입 고객
	AND T.고객번호 = C.고객번호
```

- 고객 테이블에서 ‘전월 이후 가입한 고객'을 필터링 하는 조건이 인라인 뷰 바깥에 있기 떄문에 해당 조건이 있는데도 인라인 뷰 안에서는 당월 거래한 ‘모든' 고객의 거래 데이터를 읽어야한다.
- 뷰 머징을 방지하고자 할 땐 no_merge 힌트를 사용한다.
- 단, 조인에 성공한 전체 집합을 Group by 한 다음에만 데이터를 출력 할 수 있다.
- 부분범위 처리가 불가능하다.

# 4.4.4 스칼라 서브쿼리 조인

- 함수와 서브쿼리를 사용하면 결과 값은 같지만, 함수 아네 있는 SELECT 쿼리를 메인 쿼리 건수만큼 재귀적으로 반복한다.
- 스칼라서 서브쿼리는 레코드마다 정확히 하나의 값만 반환한다.( 재귀적으로 실행하는 구조는 아니다 ) ⇒ **컨텍스트 스위칭 없이** 메인 쿼리와 서브쿼리를 한 몸체처럼 실행한다

## 스칼라 서브쿼리 캐싱 효과

- 스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화하려고 입력 값과 출력 값을 내부 캐시에 저장해 둔다.
- 스칼라 서브쿼리로 조인하면 조인 횟수를 최소화 하기 위해서 입력 값과 출력 값을 내부 캐시에 저장해둔다.
- 조인할 때 마다 일단 캐시에서 ‘입력 값'을 찾아보고 찾으면 저장된 ‘출력 값'을 반환한다.
- 캐시에서 찾지 못할때만 조인을 수행하고 결과는 버리지 않고 캐시에 저장한다.

```sql
-- SELECT-LIST에 사용한 함수는 메인쿼리 결과 건수만큼 반복 수행되는데
-- 아래와 같이 스칼라사 서브쿼리를 덧씌우면 호출 횟수를 최소화 할 수 있다.
select empno, ename, sal, hiredate,
       (select GET_DNAME(e.deptno) from dual) dname
from   emp e
where  sal >= 2000;
```

# 스칼라 서브쿼리 캐싱 부작용

- 캐시 공간은 늘 부족하므로, 입력 값의 종류가 소수여서 해시 충돌 가능성이 작을 때 효과가 있다.
- 메인쿼리 집합이 클수록 재사용성이 높아 효과가 크다. 메인쿼리 집합이 작으면 캐시 재사용성도 낮다.

```sql
Select 거래번호, 고객번호, 영업조직ID, 거래구분코드,
   (Select 거래구분명 from 거래구분 where 거래구분코드 = t.거래구분코드) 거래구분명 
From 거래 t
where 거래일자 >= to_char(add_month(sysdate, -3), 'yyyymmdd') -- 50,000건
```

- 거래구분코드로 20개 값이 존재한다. 메인쿼리에서 50,000개 거래를 읽는 동안 거래구분코드별 조인 엑세스는 최초 한번씩만 발생한다. 이후로는 모두 캐시에서 데이터를 찾게 되므로 조인 성능을 높이는데 큰 도움이 된다.

```sql
Select 거래번호, 고객번호, 영업조직ID, 거래구분코드,
   (Select 고객명 from 고객 where 고객번호 = t.고객번호) 거래구분명 
From 거래 t
where 거래일자 >= to_char(add_month(sysdate, -3), 'yyyymmdd') -- 50,000건
```

- 고객은 100만 명이다 캐시에 도저히 담을 수 없을 만큼 많이 존재한다.
- 메인 쿼리에서 50,000개 거래를 읽는 동안 캐시를 매번 탐색하지만, 대부분 데이터를 찾지 못해 결국 조인을 해야한다.
- 불필요한 캐시 탐색 때문에 일반 조인문보다 느리고 불필요하게 자원만 낭비한다.

## 두 개 이상의 값 반환

- 스칼라 서브쿼리는 두 개 이상의 값을 반환할 수 없다는 제약이 있다. (work-around는 존재한다)

```sql
select 고객정보, 고객명
	, to_number(substr(거래금액, 1, 10)) 평균거래금액
	, to_number(substr(거래금액, 11, 10)) 최소거래금액
	, to_number(substr(거래금액, 21)) 최대거래금액
from ( 
	select c.고객번호, c.고객명,
		  (select lpad(avg(거래금액), 10)|| lpad(min(거래금액), 10)||lpad(max(거래금액), 10)
		   from 거래
		   where 거래일시 >= trunc(sysdate, 'mm') and t.고객번호 = c.고객번호) 거래금액
		   from 고객 c
		   where c.가입일시 >= trunc(add_month(sysdate, -1), 'mm')
)
```

- 위 쿼리는 SQL 튜너들이 전통적으로 많이 사용해 온 방식이다.
- 구하는 값들을 문자열로 모두 결합하고, 바깥쪽 엑세스 쿼리에서 substr 함수로 다시 분리하는 방식이다.

```sql
select 
	c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
  from 고객 c,
      (select 고객번호, avg(거래금액) 평균거래, 
	      min(거래금액) 최소거래, max(거래금액) 최대거래
         from 거래
        where 거래일시 >= trunc(sysdate, 'mm')
        group by 고객번호) t
where c.가입일시 >= trunc(add_month(sysdate, -1), 'mm')
  and t.고객번호(+) = c.고객번호
```

- 위와 같이 인라인 뷰를 사용하면 편하다.
- 하지만 뷰를 사용하게 된다면 뷰가 머징되지 않았을때 당월 거래 전체를 읽어야 하거나, Group By 때문에 부분범위 처리가 되지 않는 문제가 있다.

## 스칼라 서브쿼리 Unnesting

- 스칼라 서브쿼리도 NL 방식으로 조인하므로 캐싱 효과가 크지 않다면 랜덤 I/O 부담이 있다.
- 병렬 (Parallel) 쿼리에서는 될 수 있으면 스칼라 서브쿼리를 사용하지 않아야 한다. 대량 데이터를 처리하는 병렬 쿼리는 해시 조인으로 처리해야 효과적이기 떄문이다.
- • *_optimizer_unnest_scalar_sq* 파라미터를 true로 설정하면 스칼라 서브쿼리를 Unnsesting 할지 여부를 옵티마이저가 결정한다