# 4.3 조인 튜닝

발표자: No
범위: 4.3
생성일시: June 9, 2022 8:17 AM
작성자: 석현임
최종편집: June 17, 2022 1:42 PM

# 4.3.3 대용량 Build Input 처리

- 대용량 테이블이어서 인메모리 해시 조인이 불가능한 상황.

1. 파티션 단계
    1. 조인하는 양쪽 집합 ( = 조인 이외의 조건절을 만족하는 레코드 )의 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝 한다.
    2. 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로써 파티션(pair)을 생성하는 단계
    3. 양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인보다 성능이 많이 떨어진다.
2. 조인 단계
    1. 파티션 단계 완료 시 각 파티션 짝(pair)에 대해 하나씩 조인을 수행하며 이때, 각각에 대한 Build Input과 Probe Input은 독립적으로 결정된다.
    2. 파티션하기 전 어느 쪽이 작은 테이블이었는지에 상관없이 각 파티션 짝 별로 작은 쪽을 Build Input 으로 선택하고 해시 테이블을 생성한다.
    3. 해시 테이블을 생성하고 나면 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색하며, 모든 파티션 짝에 대한 처리를 마칠 때까지 이 과정을 반복한다.
    
    # 4.3.4 해시 조인 실행계획 제어
    
    ```sql
    SELECT /*+ use_hash(e c) */
           e.사원번호, e.사원명, e.입사일자
         , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
      FROM 사원 e, 고객 c
     WHERE c.관리사원번호 = e.사원번호
       AND e.입사일자 >= ‘19960101’
       AND e.부서코드 = ‘Z123’
       AND c.최종주문금액 >= 2000
    ```
    
    - use_hash 힌트만 사용했으므로 Build Input을 옵티마이저가 선택하는데, 일반적으로 둘 중 카디널리티가 작은 테이블을 선택한다.
    
    ```sql
    SELECT /*+ leading(e) use_hash(e c) */ -또는 ordered use_hash(c)
           e.사원번호, e.사원명, e.입사일자
         , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
      FROM 사원 e, 고객 c
     WHERE c.관리사원번호 = e.사원번호
       AND e.입사일자 >= ‘19960101’
       AND e.부서코드 = ‘Z123’
       AND c.최종주문금액 >= 2000
    
    SELECT /*+ leading(e) use_hash(e c) swap_join_inputs(c) */
           e.사원번호, e.사원명, e.입사일자
         , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
      FROM 사원 e, 고객 c
     WHERE c.관리사원번호 = e.사원번호
       AND e.입사일자 >= ‘19960101’
       AND e.부서코드 = ‘Z123’
       AND c.최종주문금액 >= 2000
    ```
    
    - 조인 대상 테이블이 두개 뿐이라면 leading 이나 ordered 힌트를 사용하면 된다. 오라클은 기본적으로 힌트로 지시한 순서에 따라 가장 먼저 읽는 테이블을 Build Input으로 선택한다.
    - swap_join_inputs 힌트로 Bild Input을 명시적으로 선택할 수도 있다.
    
    # 4.3.5 조인 메소드 선택 기준
    
    - 소량 데이터를 조인할 때 → NL 조인
    - 대량 데이터를 조인할 때  → 해시 조인
    - 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 떄, 즉 조인 조건식으로 등치(=) 조건이 아닐때 
    → 소트 머지 조인
    
    여기서 소량 대량은 데이터량이 많고 적음이 아닌 NL 기준으로 최적화 하였음에도 불구하고 랜덤 엑세스가 많아 만족할만한 성능을 낼 수 없다면 대랑 데이터 조인에 해당된다.
    
    수행빈도가 매우 높은 쿼리 기준
    
    1. (최적화된) NL 조인과 해시 조인 성능이 같으면 → NL 조인
    2. 해시 조인보다 약간 더 빠름 → NL 조인
    3. NL 조인보다 해시 조인이 매우 빠른 경우(= 대량 데이터 조인) → 해시 조인
    
    **NL 조인을 가장 먼저 고려해야하는 이유**
    
    - NL 조인에 사용되는 인덱스는 DBA가 Drop하지 않는 한 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 구조
    - 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조
    - 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가하며, 해시 맵을 만드는 과정에서 여러 가지 래치 경합도 발생한다.
    
    해시 조인 세가지 조건을 만족하는 SQL문
    
    - 수행 빈도가 낮고
    - 쿼리 수행 시간이 오래 걸리는
    - 대량 데이터를 조인할 때