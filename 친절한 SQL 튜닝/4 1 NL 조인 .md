# 4.1 NL 조인

# 4.1.1 기본 메커니즘

```c
for(int i=0; i<100; i++){ -- outer loop
    for(in j=0; j<100; j++){ -- inner loop
        // Do anything.,,
    }
}
```

- NL조인은 위 중첩 루프문과 같은 수행 구조를 사용한다.

```c
begin
    for outer in (select 사원번호, 사원명 from 사원 where 입사일자 >= ‘19960101’)
        loop -- outer 루프
            for inner in (select 고객명, 전화번호 from 고객 where 관리사원번호 = outer.사원번호)
            loop -- inner 루프
            dbms_output.put_line(
               outer.사원명 || ‘:’ || inner.고객명 || ‘:’ || inner.전화번호);
        end loop;
    end loop;
end;
```

- 위 코드는 PL/SQL 코드는 NL 조인이 어떤 순서로 데이터를 엑세스 하는지 설명한다.
- 일반적으로 NL 조인은 Outer과 Innser 양쪽 테이블 모두 인덱스를 사용한다.
- Outer 쪽 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다. Table Full Scan하더라도 한번에 그치기 떄문이다.
- Inner 쪽 테이블은 인덱스를 사용해야한다. Inner 루프에서 관리사번번호로 고객 데이터를 검색할 때 인덱스를 이용하 않으면 Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다
- NL 조인은 ‘인덱스를 이용한 조인 방식'이라고 할 수 있다.

# 4.1.2 NL 조인 실행계획 제어

```sql
select/*+ ordered use_nl(c) */
	e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
	and c.관리자사원번호 = e.사원번호
```

- ordered 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지사할 떄 ㅅ용한다.
- use_nl 힌트는 같이 사용했으므로 사원 테이블 기준으로 고객테이블과 NL 방식으로 조인하라는 뜻이다

```sql
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */
from A, B, C, D
where ....
```

- 3개 이상 테이블을 조인할 떄는 힌트를 위와 같이 사용한다.

```sql
select /*+ use_nl(A, B, C, D) */
from A, B, C, D
where ....
```

- 4개의 테이블을 NL 방식으로 조인하되 순서는 옵티마이저가 스스로 정하도록 맡긴 것이다.

# 4.1.3 NL 조인 수행 과정 분석

```sql
select /*+ ordered use_nl(c) index(e) index(c) */
	e.사원번호, e.사원명, e.입사일자, 
	c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
	and e.입사일자 >= '19960101'
	and e.부서코드 = 'Z123'
	and c.최종주문금액 >= 20000
```

> - 사원_PK : 사원번호
- 사원_X1 : 입사일자
- 고객_PK : 고객번호
- 고객_X1 : 관리사원번호 
- 고객_X2 : 최종주문금액
> 
1. 입사일자 ≥ ‘19960101’ 조건을 만족하는 레크를 찾기위해 사원 X1 인덱스를 Range 스캔한다.
2. 사원_X1 인덱스에서 읽은 ROWID로 사원 테이블을 액세스해서 부서코드 = ‘Z123’필터 조건을 만족하는지 확인한다.
3. 사원테이블에거 읽은 사원번호 값으로 조인 조건을 만족하는 고객 쪽 레코드를 찾으려고 고객_X1 인덱스를 Range 스캔한다.
4. 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액 ≥ 20000 필터 조건을 만족하는지 확인한다.

# 4.1.4 NL 조인 튜닝 포인트

- 조건절에 해당하는 Outer 로우 수가 많고 조인에 성공한 Inner 로우 수가 적다면, 조인 순서를 바꿔보는 것도 좋다.
- 조인 순서를 변경해서 랜덤 엑세스 발생량을 줄일 수 있는지, 더 효과적인 다른 인덱스가 있는지 등 검토한다. 필요하다면, 인덱스 추가 또는 구성 변경도 고려해 본다.
- 검토결과 NL 조인을 사용하지 못한다고 판단될 경우 소트 머지 조인이나 해시 조인을 검토한다.

# 4.1.5 NL 조인 특징 요약

- NL 조인의 첫 번째 특징은 랜덤 엑세스 위주의 조인 방식이라는 점이다.
    - 레코드 하나를 읽기 위해 블록을 통째로 읽어 비효율이 존자한다.
    - 인덱스 구성이 아무리 완벽해도 대량 데이터 조인할 떄 NL 조인이 불리한 이유이다.
- NL 조인은 조인한 레코드씩 순차적으로 진행한다는 점이다.
    - 아무리 큰 테이블을 조인하더라고 매우 빠른 응답 속도를 낼 수 있다.
- 다른 조인 방식과 비교할 때 인덱스 구성 전략이 특히 중요하다는 것도 NL 조인의 중요한 특징이다
- NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 온라인 트랙잭션 처리 시스템에 적합한 조인 방식이다.

# 4.1.6 NL 조인 튜닝 실습

Page 265 ~ 269

# 4.1.7 NL 조인 확장 메커니즘

- 테이블 Prefetch는 인덱스를 이용해 테이블을 엑세스하다가 디스크 I/O가 필요해지면 곧 읽게 될 블로까지 미리 읽어 버퍼캐시에 적재하는 기능이다.
- 배치 I/O는 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능이다.

# 4.1.7  NL 조인 확장 메커니즘

- 오라클의 경우 버전이 올라가면서 조인 성능을 높이기 위해 테이블의 Prefecth, Batch I/O 기능이 도입되었다.
- 테이블 Prefetch
    - 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능.
    - 실행계획에 인덱스 rowid에 의한 Inner 테이블 액세스가 Nested Loops 위쪽에 표시되면, Prefetch 기능이 활성화됨을 의미한다.
- 배치 I/O
    - 디스크 I/O Call을 미뤘다가 일정 블록이 일정량 쌓이면 한꺼번에 처리하는 기능이다.
    - Inner쪽 인덱스만으로 조인을 하고나서 테이블과의 조인은 나중에 일괄처리하는 메커니즘으로 테이블 액세스는 나중에 하지만 부분범위처리는 정상적으로 작동한다.
    - 인덱스와의 조인을 모두 완료하고 나서 테이블을 액세스하는 것이 아니라 일정량씩 나누어 처리한다. (부분범위처리)