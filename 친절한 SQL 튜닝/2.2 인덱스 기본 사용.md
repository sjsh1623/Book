# 2.2 인덱스 기본 사용법

# 2.2.1 인덱스를 사용한다는 것

인덱스 컬럼 (선두 컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용이 가능하다.

- 리프 블록에서 스캔 시작점을 찾아 스캔하다가 중간에 멈추는것을 의미한다

**Index Range Scan**

- 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수 도 없어 리프 블록 전체를 스캔해야만 한다.

**Index Full Scan**

- 리프 블록 전체 스캔

# 2.2.2 인덱스를 Range Scan 할 수 없는 이유

- Index Range Scan을 하려면 인덱스 컬럼을 가공하지 않은 상태로 조건절에 사용해야한다.
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 떄문이다. Index Range Scan은 인덱스에서 일정 범위를 스캔한다는 뜻이며 일정 범위를 스캔하시 위해서는 ‘시작점’과 ‘끝지점'이 있어야한다

# 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스 컬럼을 가공하면 정상적으로 Range Scan을 할 수 없다.
- 인덱스를 Range Scan 하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 저건절에 있어야한다. 반대로 말해, 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다.

**인덱스를 잘 타니까 튜닝 끝?**

- 실행계획에서 인덱스를 정말 잘 타는지 인덱스 리프 블록에서 스캔하는 양을 따져봐야 한다

# 2.2.4 인덱스를 이용한 소트 연산 생략

인덱스 Range Scan을 할 수 있는 이유는 데이터가 정렬돼 있기 떄문이다.

인덱스를 스캔하면서 출력한 결과집합이 변경 순번 순으로 정렬되기 떄문에 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지는 않는다

# 2.2.5 ORDER BY 절에서 컬럼 가공

인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다 (인덱스 컬럼은 대개 조건절에 사용한 컬럼)

하지만 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 존재한다.

1. Index [장비번호 + 변경일자 + 변경순번]

    ```sql
    SELECT 
    FROM 상태변경이력
    WHERE 장비번호 ='C'
    ORDER BY 변경일자, 변경순번 // 변경일자 + 변경 순번 순으로 정렬되기에 생략
    
    SELECT 
    FROM 상태변경이력
    WHERE 장비번호 ='C'
    ORDER BY 변경일자 || 변경순번 //OR 절로 인해 생략이 불가능 하다
    ```

    1. Index [주문일자 + 주문번호]

    ```sql
    SELECT *
    FROM (
             SELECT TO_CHAR( A.주문번호, 'FM00000') AS 주문번호, A. 업체번호, A.주문금액
            FROM 주문 A
            WHERE A.주문일자 =: dt
                    AND A.주문번호 > NVL(:next_ord_no, 0)
            ORDER BY **A.**주문번호
            )
    WHERE ROWNUM <=30
    ```

   위 퀴리를 실행계획으로 확인하게 되면 SORT ORDER BY STOPKEY 연산이 추가되어있다.

   이유는 ORDER BY 절 에 기술한 ‘주문번호'는 순수한 주문번호가 아닌 TO_CHAR함수로 가공한 주문번호 이기 때문이다.

   해결방법: 진짜 주문번호를 가리키게 주문번호를 명시한다. (alias를 걸어준다.)

   # 2.2.6 SELECT-LIST에서 컬럼 가공

   인덱스 [장비번호 + 변경일자 + 변경순번]

    ```sql
    select min(변경순번)
    from 상태변경이력
    where 장비번호='C'
    	and 변경일자='2180316';
    ```

   수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 첫번째 있는 레코드가 바로 최소값이기에 따로 정렬 연산을 하지 않는다

    ```sql
    select max(변경순번)
    from 상태변경이력
    where 장비번호='C'
    	and 변경일자='2180316';
    ```

   위 SQL또한 동일하게 수직적 탐색을 통해 가장 오른쪽 지점으로 내려가기때문에 따로 정렬 연산을 하지 않는다.

    ```sql
    select nvl(max(to_number(변경순번)),0)
    from 상태변경이력
    where 장비번호='C'
    	and 변경일자='2180316';.
    ```

   인덱스는 문자열 기준으로 정렬되어 있는데 select 절에서 to_number 함수를 사용하여 변경 순번을 가공하였기 때문에 정렬연산을 한다.

    ```sql
    select nvl(to_number(max(변경순번)),0)
    from 상태변경이력
    where 장비번호='C'
    	and 변경일자='2180316';
    ```

   max 값을 가장 먼저 찾았기 떄문에 정렬연산을 하지 않는다

   # 2.2.7 자동 형변환

    ```sql
    SELECT *
      FROM 고객
     WHERE 생년월일 = 19821225
    
    // 옵티마이저가 아래의 SQL 처럼 형변환을 하였다
    SELECT *
      FROM 고객
     WHERE TO_NUMBER(생년월일) = 19821225
    ```

   SQL에서 조건절을 가공하지 않았음에도 불구하고 옵티마이저는 형변환을 하여 테이블 전체 스캔을 하였다. 이는 생년월일 컬림이 문자형인데 조건절 비교값으로 숫자형으로 표현하여 자동으로 형변환하여 인덱스 컬럼이 가공되었기 떄문에 인덱스 Range Scan을 할 수 없게 된 것이다.
