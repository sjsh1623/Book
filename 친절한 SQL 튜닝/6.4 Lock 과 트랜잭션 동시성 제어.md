# 6.4 Lock 과 트랜잭션 동시성 제어

발표자: No
범위: 6.4
생성일시: June 27, 2022 1:46 PM
작성자: 석현임
최종편집: June 30, 2022 9:08 AM

# 6.4.1 오라클 Lock

- 오라클은 공유 리소스와 사용자 테이블을 보호할 목적으로 여러가지 종류의 Lock을 사용한다.
- 래치는 SGA에 공유된 각종 자료구조를 보호하기 위해 사용한다
- 버퍼 Lock은 버퍼 블록에 대한 엑세스롤 직렬화하기 위해 사용한다.
- 라이브러리 캐시 Lock과 Pin은 라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해 사용
- 애플리케이션 개발 측면에서 가장 중요하기 다루어야 할 Lock은 DML Lock이다. DML Lock은 다중 트랜잭션이 동시에 엑세스하는 사용자 데이터의 무결성을 보호해 준다.

**DML 로우 Lock**

- DML 로우 Lock은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다.
- 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야한다.
- Insert에 개한 로우 Lock 경합은 Unique 인덱스가 있을 때만 발생한다.
- 블로킹이 발생하면, 후행 트랜잭션은 기다렸다가 선행 트랜잭션이 커밋하면 INSERT에 실패하고 롤백하면 성공한다
- 두 트랜잭션이 다른 값을 입력하거나 Unique 인덱스사 아예 없으면 Insert에 대한 로우 Lock 경합은 발생하지 않는다.
- MVCC 모델을 사용하지 않으면 SELECT문에 Lock에 Shared Lock이 걸린다.
- Shared Lock은 배타적 Lock은 호환되지 않기 떄문에 DML과 SELECT가 서로 진행을 방해할 수 있다
- 다른 트랜잭션이 읽고 있는 로우를 변경하려면 다음 레코드로 이동할 때까지 기다려야 하고, 다른 트랜잭션이 변경 중인 로우를 읽으려면 커밋할 때까지 기다려야한다.

**DML 테이블 Lock**

DML 로우 Lock을 설정하가에 앞서 테이블 Lock을 먼저 설정한다. 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위해서 이다

|  | Null | row share | row exclusive | share | share row exclusive | exclusive |
| --- | --- | --- | --- | --- | --- | --- |
| Null | O | O | O | O | O | O |
| row share | O | O | O | O | O |  |
| row share | O | O | O |  |  |  |
| share | O | O |  | O |  |  |
| share | O | O |  |  |  |  |
| share | O |  |  |  |  |  |
- 선행 트랜잭션과 호환되지 않는 모드로 테이블 Lock을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야 한다.
- RS, RX 간에는 어떤 조합으로도 호환이 되므로 SELECT FOR UPDATE나 DML문 수행 시 테이블 Lock에 의한 경합은 절대 발생하지 않는다. 같은 로우를 갱신하려고 할 때만 로우 Lock에 의한 경합이 발생한다.

**Lock을 푸는 열쇠, 커밋**

- 블로킹은 선행 트랜잭션이 설정한 Lock 떄문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있 는 상태를 말한다. **이것을 해소하는 방법은 커밋뿐이다.**
- 교착상태(DeadLock)는 두 트랜잭션이 각각 특정 리소스에 Lock을 설정한 상태에서 맞은편 트랜잭션이 Lock을 설정한 리소스에 또 Lock을 설정하려고 진행하려는 상황을 말한다.
- 불필요하게 커밋을 너무 자주 수행하면 서버 프로세스가 LGWR에게 로그 버퍼를 비우도록 요청하고 동기(sync) 방식으로 기다리는 횟수가 늘기 떄문에 기본적으로 성능이 느려진다.

 **배치 커밋**

- WAIT : LGWR가 로그버퍼를 파일에 기록했다는 완료메시지를 받을때까지 기다린다
- NOWAIT : LGWR가 완료메시지 기다리지 않고 다음 트랜잭션 진행한다
- IMMEDIATE : 커밋 명령을 받을 때마다 LGWR가 로그버퍼를 파일에 기록한다
- BATCH : 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다 일괄 처리한다

# 6.4.2 트랜잭션 동시성 제어

- 비관적 동시성 제어 (Pessimistic Concurrency Control)는 사용자들이 같은 데이터를 동시에 수정할 것으로 가정한다. 한 사용자가 데이터를 읽는 시점에 Lock을 걸로 조회 또는 갱신처리가 완료 될때까지 이를 유지한다
- Lock은 사용자들이 트랜잭션을 완료하기 전까지 다른 사용자들도 데이트를 수정 할 수 없게 만들기 때문에 비관적 동시성 제어를 잘못 사용하면 동시성이 나빠진다.

**비관적 동시성 제어**

- 아래의 SELECT문 이후 Update 트랜잭션이 같은 고객의 실정정보를 변경한다면 문제가 생길 수 있다.

```sql
-- 산출 공식을 이용해 적립 포인트를 계산
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 from 고객 
where 고객번호 = :cust_num for update; 

-- 새로운 적립포인트 계산 

update 고객 set 적립포인트 = :적립포인트 where 고객번호 = :cust_num;
```

- select 시점에 Lock을 거는 비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있다. 그러므로 아래와 같이 wait 또는 nowait 옵션을 함께 사용하는 것이 바람직하다.

```sql
for update nowait → 대기없이 Exception을 던짐 for update wait 3 → 3초 대기 후 Exception을 던짐
```

**낙관적 동시성 제어**

- 낙관적 동시성 제어(Optimistic Concurrency Control)에선 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정한다. 따라서 데이터를 읽을 때는 Lock을 설정하지 않는다. 대신 수정 시점에, 다른 사용자에 의해 값이 변경됐는지를 반드시 검사해야 한다

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 into :a, :b, :c, :d
from 고객 where 고객번호 = :cust_num; 

-- 새로운 적립포인트 계산 

update 고객 set 적립포인트 = :적립포인트 
where 고객번호 = :cust_num 
and 적립포인트 = :a 
and 방문횟수 = :b 
and 최근방문일시 = :c 
and 구매실적 = :d ; 

if sql%rowcount = 0 then alert('다른 사용자에 의해 변경되었습니다.'); end if;
```

최종변경일시를 관리하는 컬럼이 있다면 이를 조건절에 넣어 더 간단하게 구현할 수 있다.

```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적, 변경일시 into :a, :b, :c, :d, :mod_dt 
from 고객 where 고객번호 = :cust_num; 

-- 새로운 적립포인트 계산 

update 고객 set 적립포인트 = :적립포인트, 변경일시 = SYSDATE 
where 고객번호 = :cust_num 
and 변경일시 = :mod_dt ;→ 최종 변경일시가 앞서 읽은 값과 같은지 비교
```

**데이터 품질과 동시성 향상을 위한 제언**

- 다중 트랜잭션이 존재하는 데이터베이스 환경에서 공유 자원에 대한 엑세스 직렬화는 필수다. (Java의 멀티쓰레드 프로그래밍  synchromized 키워드)
- FOR UPDATE 사용을 두려워 하지 말고 FOR UPDATE가 필요한 상황이면 이를 정확히 사용하고 번거롭더라도 동시성이 나빠지지 않게 WAIT 또는 NOWAIT 옵션을 활용한 예외처리에 주의를 기울여야 한다.
- 트랜잭션을 재상할 수 있는 경우 (원본 데이터를 읽어 가공된 데이터를 생성하는 경우) 라면 중간에 적당한 주기로 커밋하는 방안도 고려할 수 있다. 꼭 주간에 수핼할 필요가 없는 배치 프로그램은 야간 시간대에 수행하느것도 방법이다.
- 낙관적, 비관적 동시성 제어를 같이 사용하는 방법도 있다. 일단 낙관적 동시성 제어를 시도했다가 다른 트랜잭션에 의해 데이터가 변경된 사실이 발견되면 롤백하고 다시 시도할 떄 비관적 동시성 제어를 하는 방식이다.

# 6.4.3 채번 방식에 따른 INSERT 성능 비교

- INSERT, UPDATE, DELTET, MERGE중 채번 방식에 따라 INSERT가 성능 차이가 매우크기 때문에 가장 중요하고 튜닝 요소가 많다.
- 채번 테이블
    - 각 테이블 식별자의 단일컬럼 일련번호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식이다.
    - 채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드를 입력하는 데 사용한다.
    
    장점
    
    - 범용성이 좋다
    - INSERT 과정에 중복 레코드 발생에 대한 예외 처리에 크게 신경쓰지 않아도 되므로 채번 함수만 잘 정의하면 편리하게 사용할 수 있다
    - INSERT 과정에 결번을 방지할 수 있다
    - PK가 복합컬럼일 떄도 사용할 수 있다.
    
    단점
    
    - 채번 레코드를 변경하기 위한 Lock 경합으로 다른 채번 방식에 비해 성능이 안 좋다.
    - INSERT가 아주 많으면 채번 레코드뿐만 아니라 채번 테이블 블록 자체에도 경합이 발생한다.
- 시퀀스 오브젝트
    
    장점
    
    - 성능이 빠르다
    - 채번 테이블과 마찬가지로 INSERT 과정에 중복 레코드 발생에 대한 예외처리에 크게 신경 쓰지 않아도 된다
    - 즉, 개발팀에서 사용하기 편리하다
    
    단점
    
    - 기본적으로 PK가 단일컬럼일 때만 사용 가능하다는 데 있다. PK가 복합컬럼일 떄도 사용할 수는 있지만. 각 레코드를 유일하게 식별하는 최소 컬럼으로 PK를 구성해야 한다는 최소성 요건을 위배하게 된다.
    - 시퀀스 채번 이후에 트랜잭션을 롤백하는 경우, CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우 결번이 생길 수 있다.
    
    시퀀스 오브젝트도 결국 테이블이므로 값을 일고 변경하는 과정에 Lock 메커니즘이 자ㅏ동한다. 시퀀스 Lock에 의한 성능 이슈가 있지만, 캐시 사이지를 적절히 설정하면 가장 빠른 성능을 제공한다.
    
    1. 로우 캐시 Lock
    - 로우 캐시는 공유 캐시(SGA)구성요소로 정보를 읽고 쓸 떄 엑세스 직렬화에 쓰이는 Lock이다
    - 시퀀스 채번으로 인한 로우 캐시 Lock 경합을 줄이기 위해 오라클은 기본적으로 CACHE 옵션을 사용한다.
    1. 시퀀스 캐시 Lock
    - 시퀀스 캐시도 공유 캐시에 위치한다. 따라서 시퀀스 캐시에서 값을 얻을 때오 엑세스 직렬화에 쓰이는 Lock이다
    1. SV Lock
    - 시퀀스 캐시는 한 인스턴스 내에서 공유된다. nextval을 호출하는 순서대로 값을 제공하므로 인스턴스 내에서는 번호 순서를 보장한다.
    - 데이터베이스 하나에 인스턴스가 여러 개인 RAC 환경에서는 인스턴스마다 시퀀스 캐시를 따로 갖기때문에 인스턴스 간에는 번호 순서를 기본적으로 보장하지 않는다.
    - 어떤 인스턴스에서 nextval을 호출하더라도 순서대로 일련번호를 제공해야 한다면. ORDER 옵션을 사용하면 된다. 그러면 시퀀스 캐시 하나를 모든 RAC 노드가 공유한다.
    
    RAC 환경에서 ORDER 옵션에 따라 성능 차이가 많이 나지만 시퀀스를 이용한 채번이 가장 빠르다.
    
- MAX + 1 조회
    
    대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT하는 방식
    
    ```sql
    insert into 상품거래(거래일련번호, 계좌번호, 거래일시, 상품코드, 거래가격, 거래수량)
    value ((select max(거래일련번호) + 1 from 상품거래)
    				, :acnt_no, sysdate, :prod_cd, :trd_price, :trd_qty);
    ```
    
     장점
    
    - 시퀀스 또는 별도의 채번 테이블을 관리하는 부담이 없다.
    - 동시 트랜잭션에 의한 충돌이 많지 않으면 성능이 매우 빠르다
    - PK가 복합컬럼인 경우, 즉 구분 속성별 순번을 채번할 때도 사용할 수 있다.
        - 채번 테이블은 구분 속성 값이 많을수록 성능이 더 좋아진다. 입력 값 중복에 의한 Row Lock 경합이 줄어들고 재실행 횟수도 줄기 떄문이다.
    
    단점
    
    - 레코드 중복에 대비한 세밀한 예외처리가 필요하다.
    - 다중 트랜잭션에 의한 동시 채번(Row Lock 경합)이 심하면 시퀀스보다 성능이 많이 나빠질 수 있다.

**Lock 경합 요소를 고려한 채번 방식 선택**

1. 다중 트랜잭션에 의한 동시 채번이 많지 않으면, 세가지 어떤 방식이던 상관 없지만 가급적 MAX + 1 방식을 선택하는것이 좋다.
2. 다중 트랜잭션에 의한 동시 채번이 많고 PK가 단일컬럼 일련번호라면, 시퀀스 방식이 가장 좋다
3. 가중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종유 개수가 적으면 MAX + 1 방식은 성능에 문제가 생길 수 있음으로 순환 옵션을 가진 시퀀스 오브젝트 활용을 고려할 수 있다.

**시퀀스 보다 좋은 솔루션**

- 한개 이상의 구분 속성과 함께 뒤쪽에 순번 대신 입력일시를 두는 방식으로 PK 구조를 설계하면, 채번 또는 INSERT 과정에 생기는 Lock 이슈를 거의 해소할 수 있다.
- 채번 과정을 생략하고 SYSDATE 또는 SYSTIMESTAMP 함수만 호출하면 되기 떄문이다.
- 정보생명주기를 효과적으로 관리하는 데 있어 데이터 삭제는 매우 중요하다. 데이터베이스도 빠르게 입력하는 만큼 빠르게 삭제할 수 있어야 좋다.
- 빠르게 삭제할 뿐만 아니라, 삭제한 공간을 바로 시스템에 반납함으로써 새로 입력하는 데이터를 위해 재사용할 수 있어야 한다.
- 입력일시를 PK에 포함하는것은 유의미하다. 파티션을 활용한 대량 DELETE 튜닝에서 설명한 것 처럼 서비스 중단 없이 파티션 단위로 커틴하려면 기본적으로 PK 인덱스가 로컬 파티션이어야 하고 PK 인덱스를 로컬 파티셔닝하려면 삭제 기준 컬럼이 PK에 포함돼 있어야 한다.

**인덱스 블록 경합**

- INSERT 성능이 너무 빠르면 인덱스 경합이 발생 할 수 있다.
- 채번 테이블 Row Lock이나 시퀀스 Lock이 앞에서 길을 가로 막고 있으면 잘 나타나지 않지만 채번 과정을 생략하는 순간부터 인덱스 블록 경합이 나타나기 시작한다.
- 인덱스 블록 경합을 해소하는 가장 일반적은 방법은 인덱스를 해시 파티셔닝 하는 것이다.
- 인덱스를 해시 파티셔닝하면 값이 순차적으로 증가하더라고 해시 함수가 리턴한 값에 따라 서로 다른 파티션에 입력되므로 경합을 줄일 수 있다.