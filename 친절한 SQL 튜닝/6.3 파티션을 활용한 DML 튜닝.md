# 6.3 파티션을 활용한 DML 튜닝

발표자: Yes
범위: 6.3
생성일시: June 23, 2022 10:14 PM
작성자: 석현임
최종편집: June 27, 2022 1:52 PM

# 6.3.1 테이블 파티션

파티셔닝(Partitioning)은 테이블 또는 인덱스 데이터를 특정 컬럼값에 별로 세그먼트에 나눠서 저장하는 것을 말한다. 

파티션이 필요한 이유

- 관리적 측면: 파티션 단위 백업, 추가, 삭제, 변경 → 가용성 향상
- 성능적 측면 : 파티션 단위 조회 및 DML, 경합 또는 부하 분산

파티션 종류

- Range 파티션
    - 오라클 8 버전부터 제공된 가장 기초적인 방식
        
        ```sql
        CREATE TABLE 주문(
              주문번호 NUMBER
            , 주문일자 VARCHAR2(8)
            , 고객ID VARCHAR2(5)
            , 배송일자 VARCHAR2(8)
            , 주문금액 NUMBER
            , … 
        )
        PARTITION BY RANGE(주문일자) (
              PARTITION P2017_Q1 VALUES LESS THAN (‘20170401’)
            , PARTITION P2017_Q2 VALUES LESS THAN (‘20170701’)
            , PARTITION P2017_Q3 VALUES LESS THAN (‘20171001’)
            , PARTITION P2017_Q4 VALUES LESS THAN (‘20180101’)
            , PARTITION P2018_Q1 VALUES LESS THAN (‘20180401’)
            , PARTITION P9999_MX VALUES LESS THAN (MAXVALUE) -> 주문일자 >= ‘20180401’
        );
        
        ```
        
    - 각 레코드를 파티션 키 값에 따라 분할 저장하고, 읽을 떄도 검색 조건을 만족하는 파티션만 골라 읽을 수 있어 이력성 데이터를 Full Scan 방식으로 조회할때 성능이 향상된다.
    
    **Pruning (불필요한 부분을 제거)**
    
    - 파티셔닝을 통해 (예 100만 건 단위로 나눔) Full Scan 하더라도 전체가 아닌 일부 파티션 세그먼트만 읽고 멈출 수 있어 성능 향상
- 해시 파티션
    - 오라클 8i 버전부터 제공
    - 파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식
    - 파티션 개수만 사용자가 결정하고 데이터를 분산하는 알고리즘은 오라클 내부 해시 함수가 결정한다.
    
    ```sql
    CREATE TABLE 고객(
          고객ID VARCHAR2(5)
        , 고객명 VARCHAR2(10)
        , … 
    )
    PARTITION BY HASH(고객ID) PARTITIONS 4
    ```
    
    - 검색할 때는 조건절 비교 값(상수 또는 변수)에 똑같은 해시 함수를 적용함으로써 읽을 파티션을 결정한다. 해시 알고리즘 특성상 등치(=) 조건 또는 IN-List 조건으로 검색할 때만 파티션 Pruning이 작동한다
- 리스트 파티션
    - 오라클 9i 버전부터 제공
    - 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장하는 방식
    
    ```sql
    CREATE TABLE 인터넷매물(
          물건코드 VARCHAR2(5)
        , 지역분류 VARCHAR2(4)
        , …
    )
    PARTITION BY LIST(지역분류) (
          PARTITION P_지역1 VALUES (‘서울’)
        , PARTITION P_지역2 VALUES (‘경기’. ‘인천’)
        , PARTITION P_지역3 VALUES (‘부산’, ‘대구’, ‘대전’, ‘광주’)
        , PARTITION P_기타 VALUES (DEFAULT) -> 기타 지역
    );
    ```
    
    - 값의 순서와 상관없이 불연속적인 값의 목록에 의해 결정된다.
    - 해시 파티션과 비교하면, 해시 파티션은 오라클이 정한 해시 알고리즘에 따라 임의로 분할하는 반면, 리스트 파티션은 사용자가 정의한 논리적인 그룹에 따라 분할한다.
    
    # 6.3.2 인덱스 파티션
    
    인덱스 파티션은 테이블 파티션과 맞물려 다양한 구성이 존재한다.
    
    - 비파티션 테이블 (Non-Partitioned Table)
    - 파티션 테이블(Partitioned Table)
    
    인덱스도 테이블처럼 파티션 여부에 따라 파티션 인덱스와 비파티션 인덱스로 나뉘고, 파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 로컬과 글로벌로 나뉜다.
    
    - 로컬 파티션 인덱스 (Local Partition Index)
        
        ```sql
        create index 주문_x01 on 주문 (주문일자, 주문금액) **LOCAL**;
        create index 주문_x02 on 주문 (고객ID, 주문일자) **LOCAL**;
        ```
        
        - 인덱스 파티션은 테이블 파티션 속성을 그대로 상속 받는다
        - 테이블 파티션 키가 주문일자면 인덱스 파티션 키도 주문일자가 된다.
        - 로컬 파티션 인덱스를 ‘로컬 인덱스'라고 줄여서 부르기도 한다.
        - 테이블 파티션 구성을 변경하더라도 (add, drop, exchange) 인덱스를 재생성할 필요가 없다.
        - 변경작업이 순식간에 끝나므로 피크 시간대만 피하면 서비스를 중단하지 않고도 작업할 수 있다.
    - 글로벌 파티션 인덱스 (Global Partitioned Index)
        - 파티션을 테이블과 다르게 구성한 인덱스이다.
        - 파티션 유형이 다르거나, 파티션 키가 다르거나, 파티션 기준값 정의가 다른 경우
        - 비파티션 테이블이어도 인덱스는 파티셔닝할 수 있다.
        - CRREAT INDEX 문 뒤에 ‘GLOBAL” 키워드를 추가하여 파티션을 정의한다
        
        ```sql
        create index 주문_x03 on 주문 (주문금액, 주문일자) **GLOBAL**
        partition by range(주문금액) (
        	partition P_01 values less than (100000)
        	partition P_MX values less than (MAXVALUE) --> 주문금액 >= 100000
        );
        ```
        
        - 글로벌 파티션 인덱스는 테이블 파티션 구성을 변경 (drop, exchange, split 등) 하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다. 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.
        - 파티션을 직접관하여 1:1 관계가 되도록 할 수 있지만 그렇다고 로컬 파티션이 아니다. 오라클이 인덱스 파티션을 자동으로 관리해주고 있지 않기 때문에 글로벌 파티션에 속한다
    - 비파티션 인덱스(Non-Partitioned Index)
        
        ```sql
        create index 주문_x04 on 주문 ( 고객ID, 배송일자 );
        ```
        
        - 비파티션 인덱스는 여러 테이블 파티션을 가리킨다.
        - 비파티션 인덱스를 ‘글로벌 비파티션 인덱스’라고 부르기도 한다
        - 비파티션 인덱스는 테이블 파티션 구성을 변경 (dtop, exchange split 등) 하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재 생성해야 줘야 한다. 그동안 해당 테이블을 사용하는 서비스는 중단해야한다.
        
    
    **Prefixed vs. Nonprefixed**
    
    Prefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치한다.
    
    Nonprefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치하지 않는다. 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속한다.
    
    | 구분 | prefixed | Nonprefixed |
    | --- | --- | --- |
    | 로컬 파티션 | 1 | 2 |
    | 글로벌 파티션 | 3 | 4 (Not Support |
    
    글로벌 파티션 인덱스는 Prefixed 파티션만 지원되므로 결과적으로 세 개의 파티션 인덱스가 있고, 비파티션 인덱스를 포함해 아래 네 가지 유형으로 최종 정리 할 수 있다.
    
    - 로컬 Prefixed 파티션 인덱스
    - 로컬 Nonprefixed 파티션 인덱스
    - 글로벌 Prefixed 파티션 인덱스
    - 비파티션 인덱스
    
    **중요한 인덱스 파티션 제약**
    
    <aside>
    💡 Unique 인덱스를 파티셔닝 하려면, 파티션 키가 모두 인덱스 구성 컬럼이여야 한다
    
    </aside>
    
    - DML 성능 보장을 위해 Unique 인덱스를 파티셔닝할 때 파티션 키가 인덱스 컬럼에 포함되어야 한다.
    - 파티션 키 조건 없이 PK 인덱스로 엑세스 하는 수많은 쿼리 성능을 위해서도 필요하다.
    - Unique 인덱스를 파티셔닝 할때 파티션 키가 인덱스 컬럼에 포함되어야 하는 제약으로 인해 PK 인덱스를 로컬 파티셔닝하지 못하면 파티션 Drop, Truncate, Exchange … 같은 파티션 구조 변경 작업도 쉽지 않다. (PK 인덱스가 Unusable 상태로 변경되기 떄문).
    - 서비스 중단 없이 파티션 구조를 빠르게 변경하려면, PK를 포함한 모든 인덱스가 로컬 파티션 인덱스이어야 한다..
    
    # 6.3.3 파티션을 활용한 대량 UPDATE 튜닝
    
    - 인덱스가 DML 성능에 큰 영향을 미치므로 대량 데이터를 입력/수정/삭제할 때는 인덱스를 Drop 하거나 Unusable 상태로 변경하고서 작업하는 방법을 많이 활용한다.
    - 입력/수정/삭제하는 데이터 비중이 5%를 넘는다면 인덱스를 그대로 둔 상태에서 작업하기보다 인덱스 없이 작업한 후에 재생성하는게 더 빠르다.
    
    **파티션 Exchange를 이용한 대량 데이터 변경**
    
    1. 임시 테이블 생성. nologgin 모드로 생성
        
        ```sql
        create table 거래_t
        nologging 
        as
        select * from 거래 where 1 = 2;
        ```
        
    2. 거래 데이터를 읽어 임시 테이블에 입력하면서 상태코드 값을 수정한다.
        
        ```sql
        insert /*+ append */ into 거래_t
        select 고객번호, 거래일자, 거래순번 ... 
        	,(case when 상태코드 <> 'ZZZ' then 'ZZZ' else 상태코드 end) 상태코드
        from 거래
        where 거래일자 < '20150101';
        ```
        
    3. 임시 테이블에 원본 테이블과 같은 구조로 인덱스를 생성한다.
    4. 2014년 12월 파티션과 임시 테이블을 Exchage 한다.
        
        ```sql
        alter table 거래
        exchange partition p201412 with table 거래_t
        including indexes without validation;
        ```
        
    5. 임시 테이블을 Drop 한다.
        
        ```sql
        Drop table 거래_t;
        ```
        
    6. 파티션을 logging 모드로 전환한다.
    
    # 6.3.4 파티션을 활용한 대량 DELETE 튜닝
    
    - 인덱스를 실시간으로 관리하려면 어마어마한 시간이 소요된다.
    - 그렇다고 초대용량 테이블 인덱스를 모두 Drop 했다가 다시 생성하기도 만만치 않다.
    - UPDATE는 변경 대상 컬럼을 포함하는 인덱스만 재생성하면 되지만, DELETE는 모든 인덱스를 재생성해야한다.
    
    **파티션 Drop을 이용한 대량 데이터 삭제**
    
    - 테이블 삭제 조건절 컬럼 기준으로 파티셔닝돼 있고 인덱스도 다행이 로컬 파티션이라면, 아래와 같이 간단한 문장 하나로 대량 데이터를 순식간에 삭제 할 수 있다.
    
    ```sql
    alter table 거래 drop partition p201412;
    
    -- 오라클 11g 버전부터 사용 가능
    alter table 거래 drop partition for('20141201');
    ```
    
    **파티션 Truncate를 이용한 대량 데이터 삭제**
    
    - 조건을 만족하는 데이터가 소수이면, 아래 DELETE 문을 그래도 사용하면 된다.
        
        ```sql
        delete from 거래
        where 거래일자 < '20150101'
        and **(상태코드<> 'zzz' or 상태코드 is null)**
        ```
        
        위 조건을 만족하는 데이터가 많다면 대량 데이터를 지울 게 아니라 남길 데이터만 백업했다가 재입력하는 방식이 빠르다.
        
        1. 임시 테이블을 생성하고 남길데이터만 복제한다.
        2. 삭제 대상 테이블을 Truncate한다
        3. 임시 테이블에 복제해 둔 데이터 원본 테이블에 입력한다.
        4. 임시 테이블을 Drop 한다.
        
        서비스 중단 없이 Drop 또는 Truncate하려면 아래 조건을 모두 만족해야한다.
        
        1. 파티셔닝 키와 커팅 기준 컬럼이 일치해야한다
        2. 파티션 단위와 커팅 주기가 일치해야한다
        3. 모든 인덱스 로컬 파티션 인덱스이어야 한다.
        
    
    # 6.3.5 파티션을 활용한 대량 INSERT 튜닝
    
    **비파티션 테이블일 때**
    
    - 비파티션 테이블에 손익분기점을 넘는 대량 데이터를 INSERT 하려면 인덱스를 Unusable 시켰다가 재생성하는 방식이 더 빠를 수 있다.
    1. 테이블을 nologging 모드로 전환한다
    2. 인덱스를 unusalbe 상태로 전환한다
    3. 대량 데이터를 입력한다
    4. 인덱스를 재생성한다
    5. logging 모드로 전환한다
    
    **파티션 테이블일 때**
    
    - 테이블이 파티셔닝이 되어있고, 인덱스도 로컬 파티셔닝이라면 파티션 단위로 인덱스를 재생성 할 수 있다.
    1. 작업 대상 테이블 파티션을 nologging 모드로 전환한다.
    2. 작업 대상 테이블 파티션과 매칭되는 인덱스 파티션을 Unusable 상태로 전환한다
    3. 대량 데이터를 입력한다
    4. 인덱스 파티션을 재생성한다
    5. 작업 파티션을 Logging 모드로 전환한다.