# 3.1 테이블 엑세스 최소화

발표자: Yes
범위: 3.1
수정일: May 12, 2022 1:25 PM
작성자: 석현임

# 3.1.1 테이블 랜덤 엑세스

**인덱스 ROWID는 물리적 주소? 논리적 주소?**

- 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소 값 즉, ROWID를 얻으려는 데 있다.
- ROWID는 물리적 주소로 생각할 수도 있지만 (데이터파일 번호, 오브젝트 번호, 블록 번호 같은 물리적 요소로 구성되어있기 떄문) ROWID는 물리적 주소보다 논리적 주소에 가깝다. 물리적으로 직접 연결되는것이 아니라 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 떄문이다.

**인덱스** ⇒ 도서 색인

**ROWID** ⇒ 색인에 기록된 페이지 번호

인덱스 ROWID는 논리적 주소다. 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. 

**메인 메모리 DB와 비교**

- 메인 메모리 DB란 데이터를 모두 메모리에 로드해놓고 메모리를 통해서만 I/O를 수행하는 DB이다.
- 잘 튜닝된 OLTP성 데이터 베이스 시스템이라면 디스크를 경유하지 않고 대부분 테이터를 메모리에서 읽고 버퍼캐시 99% 히트율을 보여준다.
- 네부 아키텍처데 따라 모두 다르겠지만 메인 메모리 DB의 경우 인스턴스를 기동하면 기스크에 저장된 데이터를 버퍼캐시로 로딩하고 인덱스를 생성한다.
- 인덱스는 오라클 처럼 디스크 상의 주소정보를 갖는게 아닌 메모리상의 정보주소(포인터)를 가지게 되는데 이떄 테이블을 경유해 엑세스하는 비용이 오라클과 비교 할 수 없을 정도로 낮다.
- 그리하여 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 엑세스가 생각만큼 빠르지 않다.

**I/O 메커니즘 복습**

- DBA (데이터파일번호 + 블록번호)는 디스크 상에서 블록을 찾기 위한 주소 정보다.
- 매번 디스크 상에서 블록을 읽을수는 없다. 그러므로, I/O 성능을 높이려면 버퍼캐시를 활용해야한다.
- 해싱 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 찾아간다.
- 인덱스 테이블 블록을 엑세스할 떄는 리프 블록에서 읽은 ROWID를 분해해서 DBA 정보를 얻고, 테이블 Full Scan 할 떄는 익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻는다.
- 인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조다.

 

**인덱스 ROWID는 우편주소**

- 디스크 DB(오라클, SQL Server 같은 일반 DBMS)가 사용하는 ROWID → 우편주소
- 메인 메모리 DB가 사용하는 포인터 → 전화번호

# 3.1.2 인덱스 클러스터링 팩터

- 클러스터링 팩터 (Clustering Factor, CF)는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
- 즉, CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋다. (테이블 엑세스량에 비해 블록 I/O가 적게 발생함을 의미한다)

# 3.1.3. 인덱스 손익분기점

- 인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조이며 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다.
- 인덱스 손익분기점이란 Index Range Scan 속도가 Table Full Scan 보다 느려지는 지점이다.

인덱스를 이용한 테이블 엑세스가 Table Full Scan보다 느려지게 만드는 가장 핵심적인 이유

- Table Full Scan은 시퀀셜 엑세스인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 랜덤 엑세스 방식이다.
- Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 SIngle Block I/O 방식이다.

손인분기점은 보통 5~20%의 낮은 수준에서 결정된다.

- 버퍼캐시는 요즘 기준으로 보통 수백만개 블록을 캐싱하는 수준이다. 따라서 특정 인덱스로 100만 건 이상 엑세스 한다면 캐시 히트율은 극히 낮을 수 밖에 없다.
- 1000만 건 정도 테이블이면 인덱스 컬럼 기준으로 값이 같은 테이블 레코드가 근처에 모여 있을 가능성이 매우 낮다. 이러한 상황에 경우 손인분기점 자체가 의미 없어진다
- 1만 건이 넘어도 Table Full Scan방식으로 읽는게 더 빠를 수 있다.

**온라인 프로그램 튜닝 vs 배치 프로그램 튜닝**

- 온라인 프로그램
    - 보통 소량 데이터를 읽고 갱신한다.
    - 인덱스 사용과 NL 조인이 유리하다.
    - 인덱스를 이용해 소트 연산을 생략함으로써 2절에서 설명할 부분범위 처리 방식으로 구현할 수 있다면, 대량 데이터를 조회 할 떄도 아주 빠른 응답 속도를 낼 수 있다.
    - 배치 프로그램
        - 항상 전체 범위 처리 기준으로 튜닝해야 한다.
        - Full Scan과 해시 조인이 유리하다.
        - 초대용량 테이블을 Full Scan하면 상당히 오래 기다려야 하고 시스템이 주는 부담도 적지 않다
            - 배치 프로그램에서는 파티션 활용 전략이 매우 중요한 튜닝 요소이고, 병렬 처리까지 더할 수 있으면 금상첨화이다.
            - 성능 측면에서만 보면 테이블을 파티셔닝하는 이유는 결국 Full Scan을 빠르게 처리하기 위해서다.
        
        모든 성능문제를 인덱스로 해결하려 해선 안된다. 인덱스는 다양한 튜닝 도구 중 하나일 뿐이며, 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾고자 할 떄 주로 사용한다.
        

# 3.1.4 인덱스 컬럼 추가

테이블 엑세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는것이다.

- 부서 번호  + 업무 인덱스에서 부서번호 + 연봉으로 검색하게 된다면 부서번호에 해당되는 데이터가 많을 수록 랜덤 엑세스가 많아진다.

위 문제를 해결하기 위해 인덱스를 새로 만들어야겠지만 이런식으로 인덱스를 추가하다 보면 테이블 마다 인덱스가 수십개씩 생성될 수 있다. 인덱스가 많아지면 관리 비용이 증가함은 물론 DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다.

- 이럴 떄 기존 인덱스에 연봉 컬럼을 추가하는 것만으로 큰 효과를 얻을 수 있다.
- 인덱스의 스캔양이 줄지 않지만, 테이블 랜덤 엑세스 횟수를 줄여주기 떄문이다.

# 3.1.5 인덱스만 읽고 처리

**Cover 쿼리**

- 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 엑세스가 아예 발생하지 않게 했을 떄, 인덱스만 읽어서 처리하는 쿼리
- 효과는 매우 좋지만, 추가해야 할 컬럼이 많아 실제 적용하기 곤란한 경우도 많다.

**Include 인덱스**

```sql
//sal 컬럼을 리프 블록에만 저장
//수직적 탐색에서는 deptno만 사용, 수평적 탐색에서는 sal도 필터 조건으로 사용 가능
create index emp_x01 on emp (deptno) include (sal)

//deptno와 sal 모두 루트와 브랜치 블록에 저장
//둘 다 수직적 탐색에 사용가능
create index emp_x02 on emp(deptno, sal)

// 이럴 경우 emp_x01, emp_x02 둘다 covered index 이므로 테이블 액세스생략 가능
select sal from emp where deptno=20

//emp_x02는 소트 연산 생략 가능, emp_x01은 소트 연산 생략 불가
//include 인덱스는 순전히 테이블 랜덤 액세스를 줄이는 용도로만 개발
select * from emp where deptno=20 order by sal
```

# 3.1.6 인덱스 구조 테이블

랜덤 엑세스가 아예 발생하지 않도록 인덱스 구조를 생성하는것을 오라클은 IOT (Index Organized Table) 라고 부른다

```sql
// 테이블 인덱스 구조로 만드는 구문
create table index_org_t ( a number, b varchar(10), constraint index_org_t_pk primary key (a) )
organization index ;
```

IOT (Index Organized Table) 

- 테이블을 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 IOT는 그 자리에 테이블 데이터를 갖는다.
- 즉, 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장하고 있다.
- 일반 테이블은 힙 구조 테이블로 순서 없이 데이터를 입력하지만, IOT는 정렬 상태를 유지하며 입력한다.
- BETWEEN 이나 부등호 조건으로 넓은 범위를 읽을 때 유리하다.

# 3.1.7 클러스터 테이블

**인덱스 클러스터 테이블**

- 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다.
- 한 블록에 모두 담을 수 없을 떄는 새로운 블록을 할당해서 클러스터 체인으로 연결한다
- 여러 테이블 레코드를 같은 블록에 저장할 수도 있다.

```sql
-- 먼저 아래와 같이 클러스터를 생성한다.
create cluster c_dept# ( deptno number(2) ) index ;

-- 그리고 클러스터에 테이블을 담기 전에 아래와 같이 클러스터 인덱스를 반드시 정의해야 한다. 
-- 왜냐하면, 클러스터 인덱스는 데이터 검색 용도로 사용할 뿐만 아니라 데이터가 저장될 위치를 찾을 때도 사용하기 띠문이다.
create index c_dept#_idx on cluster c_dept#;

-- 클러스터 인덱스를 만들었으면 아래와 같이 클러스터 테이블을 생성한다.
create table dept (
  deptno number(2)    not null
, dname  varchar2(4)  not null
, loc    varchar2(13) )
cluster c_dept#( deptno );
```

- 클러스터 인덱스도 일반 B*Tree 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫번째 데이터 블록을 가리킨다는 점이 다르다.
- 클러스터 인덱스는 테이블 레코드와 1:M 관계를 갖는다. 따라서 클러스터 인덱스의 키 값은 항상 Unique하다.
- 클러스터 인덱스를 스캔하면서 값을 찾을 떄는 랜덤 엑세스가 값 하나당 한 번씩 밖에 발생하지 않는다.
- 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 떄문에 넓은 범위를 읽더라도 비효율이 없다는게 핵심 원리이다.

**해시 클러스터 테이블**

- 해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다.