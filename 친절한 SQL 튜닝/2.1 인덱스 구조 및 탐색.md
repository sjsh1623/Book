# 2.1 인덱스 구조 및 탐색

# 2.1.1 미리 보는 인덱스 튜닝

**데이터를 찾는 두 가지 방법**

> 초등학교에서 ‘홍길동’ 이름으로 학생을 찾을때에는 두가지 방법이 있다. 모든 교실을 돌며 ‘홍길동'을 찾는 방법과 교무실에서 ‘홍길동' 이름을 조회하여 교실을 찾아가는 방법이 있다.여기서 ‘홍길동'이라는 이름을 가진 학생이 많다면 전자가 빠르고, 몇 안 되면 후자가 빠르다.
>
- 테이블 전체 스캔
- 인덱스를 사용

**인덱스 튜닝의 두 가지 핵심요소**

인덱스는 큰 테이블에서 소령 데이터를 검색할 떄 사용한다. 온라인 트랙젝션 처리 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 무엇보다 중요하다.

인덱스 튜닝의 첫 번쨰 요소는 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이고, 두 번째는 테이블 엑세스 횟수를 줄이는 것이다.

인덱스 튜닝 방법

- 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다. (인덱스 스캔 효율화 튜닝이다).
    - 예) 1.0 ~ 1.5 시력을 가진 ‘홍길동' 학생을 찾을 경우, 시력으로 선 정렬 vs 이름으로 선 정렬에서 후자가 더 효율적이다. 찾는 횟수를 더 줄일 수 있기 때문이다.
- 테이블 엑세스 횟수를 줄이는 것이다. (랜덤 엑세스 최소화 튜닝) - 더 중요
    - 예) 많은 인덱스를 스캔하더라도, 그 중 조건에 부합해 테이블을 접근하는 유효 인덱스가 적은 것

**SQL 튜닝은 랜덤 I/O와의 전쟁**

SQL이 느린 이유는 거의 대부분 디스크 I/O이기 떄문에 ‘인덱스 스캔 효율화 튜닝'보다는 ‘랜덤 엑세스 최소화 튜닝'이 중요하다.

# 2.1.2 인덱스 구조

데이터베이스에서도 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야하는데 반면 인덱스를 사용하면 일부만 읽고 멈출 수 있다. 즉, 인덱스를 사용하면 전체 테이블 스캔 필요없이 범위 스캔(Range Scan)이 가능하다. 범위 스캔이 가능한 이유는 인덱스가 정렬되어있기 떄문이다.

- Balanced Tree 구조이다
- 정렬되어 있다
- 첫 노드는 root, 중간 노드는 branch, 끝 노드는 leaf 라고 한다.
- LMC(Leftmost Child)는 값이 없으며 가장 작은 값을 가진 하위 노드의 주소를 가진다.
- leaf는 값과 테이블 주소 (ROWID)를 매칭시켜 가지고 있다.

# 2.1.3 인덱스 수직적 탐색

정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정. (인덱스 스캔 시작지점을 찾는 과정)

- 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다.
- 조건을 만족하는 레코드를 찾는 과정이 아닌 조건을 만족하는 첫 번쨰 레코드가 목표 지점이다

# 2.1.4 인덱스 수평적 탐색

- 인덱스에서 본격적으로 데이터를 찾는 과정이다.
- 인덱스 리프 블록은 양방향 연결 리스트 구조이다.
- 인덱스를 수평적으로 탐색하는 이유
    - 조건절을 만족하는 데이터를 모두 찾기 위해서
    - ROWID를 얻기 위해서


# 2.1.5 결합 인덱스 구조와 탐색

인덱스 선두 컬럼을 모두 “=”조건으로 검색할 때에는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.
